---
title: "Lecture et écriture dans des fichiers externes à partir de R"
linkTitle: "Lecture/écriture dans fichiers en R"
author: "Sophie Baillargeon, Université Laval"
date: "2021-01-25"
weight: 2
slug: "lecture_ecriture_r"
lastmodifierdisplayname: "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document: 
    highlight: tango
    toc: yes
    toc_depth: 3
    number_sections: yes
  blogdown::html_page:
    highlight: tango
    toc: yes
    toc_depth: 3
    number_sections: yes
header-includes:
- \usepackage{float}
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---

```{r, setup, include = FALSE}
knitr::opts_knit$set(root.dir = "./files")
knitr::opts_chunk$set(R.options = list(width = 85))
```


***

*Note préliminaire : Lors de leur dernière mise à jour, ces notes ont été révisées en utilisant R version 4.0.3, le package `readr` version 1.4.0, le package `data.table` version 1.13.6, le package `jsonlite` version 1.7.2,  le package `readxl` version 1.3.1,  le package `rvest` version 0.3.6 et  le package `openxlsx` version 4.2.3. Pour d'autres versions, les informations peuvent différer.*

***

Maintenant que les objets R pouvant servir de structure de données ont été vus, voyons comment lire et écrire dans des fichiers externes à partir de R. Dans un cadre d'analyse de données, lire et écrire dans des fichiers permet d'importer et d'exporter des données. Nous traiterons ici seulement du cas pour lequel l'importation ou l'exportation consiste à lire ou écrire dans un fichier externe de format texte, JSON, EXCEL, HTML ou dans un format propre à R.

Pour apprendre comment lire ou écrire des données stockées dans une base de données, le lecteur est référé à la documentation d'un package permettant de communiquer avec la base de données qu'il utilise. La page web suivante répertorie plusieurs de ces packages&nbsp;: https://CRAN.R-project.org/view=Databases.


# Répertoire de travail

Avant toute chose, revenons sur le répertoire de travail (ou répertoire courant, en anglais *working directory*). Afin d'accéder à des données en R, il faut typiquement aller les lire là où elles se trouvent. Si les données se trouvent dans un fichier situé sur l'ordinateur local, dans un certain répertoire, il faut aller lire son contenu à cet endroit.

Dans toute commande R effectuant une lecture ou de l'écriture dans un fichier, il faut identifier le fichier. Il peut être identifié en utilisant son chemin d'accès complet, ou encore en utilisant un chemin d'accès relatif à un emplacement courant. Peu importe l'option choisie, le chemin doit se terminer par le nom complet du fichier, incluant son extension.

Par exemple, supposons que le fichier `data_ex.txt` se trouve dans le répertoire `C:\coursR` de l'ordinateur d'un utilisateur de R sous Windows. Le chemin d'accès complet de ce fichier est `C:\coursR\data_ex.txt`. Le chemin d'accès du fichier relatif au répertoire `C:\coursR` est pour sa part simplement le nom du fichier, soit `data_ex.txt`.

**Remarque importante**&nbsp;: Bien que le caractère utilisé pour séparer les composantes dans un chemin d'accès sous Windows soit `\`, ce caractère est réservé en R pour les «&nbsp;séquences d'échappement&nbsp;». Il s'agit de séquences ayant une signification particulière dans une chaîne de caractères (par exemple `"\t"` représente une tabulation, `"\n"` représente un retour de chariot, etc.). Dans un chemin d'accès en R, il faut plutôt séparer les composantes par le caractère `/`, ou encore par `\\`.

Lorsqu'un fichier est identifié par un chemin relatif dans une instruction, R doit faire une supposition quant au répertoire à partir duquel chercher le fichier. C'est justement l'utilité du répertoire de travail. Il s'agit de l'emplacement de base, celui à partir duquel débuter un chemin d'accès à un fichier lorsque le début du chemin n'est pas spécifié par l'utilisateur. 

Pour connaître le répertoire de travail d'une session R, il suffit de soumettre la commande suivante&nbsp;:

```{r eval = FALSE}
getwd()
```

Pour accéder au fichier `data_ex.txt` en utilisant seulement son nom, il faut d'abord s'assurer que le répertoire de travail de la session R correspond au répertoire contenant le fichier. La fonction `setwd` permet de modifier le répertoire de travail. Par exemple, la commande suivante change le répertoire de travail pour `C:\coursR`.

```{r eval = FALSE}
setwd("C:/coursR")
```

Dans une commande R, un chemin d'accès doit toujours être présenté sous forme de chaîne de caractères, donc être encadré de guillemets.

Si le répertoire de travail avait été fixé à  `"C:"`, le chemin d'accès relatif du fichier aurait été `"/coursR/data_ex.txt"` (le `"/"` au début du chemin indique que `coursR` est un répertoire et non un fichier).


## Accéder au système de fichiers

R a donc accès au système de fichiers de l'ordinateur à partir duquel la session a été démarrée. Par défaut, l'accès se fait à partir du répertoire de travail. Directement dans la console R, il est possible de voir le contenu du répertoire de travail, créer des fichiers et des répertoires, effacer des fichiers, etc. Par exemple, la fonction `dir` permet d'afficher le contenu d'un répertoire (par défaut le répertoire de travail). Pour plus d'information à ce propos, la fiche d'aide nommée `files` (ouverte avec la commande [`help(files)`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/files.html)) est un bon point de départ.

```{r, eval = FALSE}
dir()
```

```{r, echo = FALSE}
c("data_ex.csv", "data_ex.json", "data_ex.txt", "data_ex.xlsx")
```

Note&nbsp;: Tous les fichiers de la liste ci-dessus sont disponibles dans le fichier `lecture_ecriture_r_2020.zip` afin de vous permettre de reproduire les exemples de ces notes de cours.

Un bon truc pour trouver facilement le nom complet d'un fichier, qui respecte la syntaxe de R, est d'utiliser la commande suivante&nbsp;:

```{r, eval = FALSE}
file.choose()
```

Cette commande ouvre une fenêtre pour naviguer dans le système de fichiers et sélectionner un fichier. Une fois la sélection du fichier complétée, la commande `file.choose()` retourne une chaîne de caractères contenant le chemin d'accès complet du fichier sélectionné.


## Projets RStudio

Il est souvent judicieux de rassembler sous un même répertoire un programme R et tous les fichiers qu'il utilise. Les fichiers de données peuvent même être placés dans un sous-répertoire, surtout s'ils sont nombreux. 

RStudio offre l'option de transformer un répertoire qui rassemble un ou des programmes R et leurs fichiers associés en «&nbsp;projet&nbsp;». Des explications à propos de l'utilisation de projets RStudio se trouvent sur la page web suivante&nbsp;: https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects.

Les projets RStudio facilitent la gestion du répertoire de travail. En ouvrant un projet RStudio, une nouvelle session R est démarrée ayant pour répertoire de travail le répertoire de base du projet.



***


# Lecture de fichiers 

Une analyse de données en R débute typiquement par l'importation de données. Les données à importer en R peuvent provenir de toutes sortes de sources. Elles peuvent se trouver dans des fichiers sous un certain format, dans des bases de données, ou provenir directement du web. En outre, il existe plusieurs formats de fichiers pour stocker des données&nbsp;: texte (dont CSV), JSON, EXCEL, formats propres à un logiciel statistique particulier, etc. Nous aborderons ici uniquement les formats texte, CSV, JSON, EXCEL, ainsi que les formats propres à R (vus plus loin). La lecture de table HTML sur le web sera aussi introduite. Pour en savoir plus sur les autres possibilités, des références sont fournies en fin de document.

Les fonctions de base en R pour lire dans des fichiers externes sont `scan` et `readLines`. Nous ne verrons pas comment utiliser ces fonctions, car il existe des fonctions mieux adapter à la lecture de fichiers contenant des données à analyser.

Les données du data frame suivant seront utilisées dans les exemples. Il s'agit de données créées dans les notes sur les [structures de données en R](https://stt4230.rbind.io/manipulation_donnees/structures_r/), dans lesquelles deux valeurs ont été remplacées par des valeurs manquantes. Ces données se rapportent à une expérience fictive de lancers de dés.

```{r}
de_1 <- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)
de_2 <- c(1, 4, 2, 3, 5, 4, 6, 2, 5, 3)
lanceur <- rep(c("Luc", "Kim"), each = 5)
data_ex <- data.frame(de1 = de_1, de2 = de_2, lanceur = lanceur)
# Introduction de valeurs manquantes
data_ex$de2[7] <- NA
data_ex$lanceur[3] <- NA
# Affichage du date frame
data_ex
```

Avant de lire en R un fichier de données, il est utile de d'abord le visualiser afin de connaître la façon dont les données sont formatées. Cependant, il est important de ne pas modifier le fichier en le visualisant. Pour être absolument certain(e) de ne pas modifier le fichier par inadvertance, une bonne pratique est de faire une copie du fichier et de visualiser cette copie plutôt que le fichier lu en R.

## Fichier texte

La lecture de données dans un fichier texte se fait principalement avec la fonction R `read.table`. Par exemple, allons lire les données contenues dans le fichier `data_ex.txt`, qui a l'allure suivante.

```
de1	de2	lanceur
2	1	Luc
3	4	Luc
4	2	.
1	3	Luc
2	5	Luc
3	4	Kim
5	.	Kim
6	2	Kim
5	5	Kim
4	3	Kim
```

Remarquons que les valeurs manquantes dans ce fichier sont représentées par des points. Importons ces données avec `read.table`.

```{r import_texte_1}
data_ex_txt <- read.table("C:/coursR/data_ex.txt")
```

Le seul argument obligatoire dans la fonction `read.table` est le chemin d'accès au fichier à lire. Ici, il n'aurait pas été nécessaire de spécifier le chemin d'accès complet du fichier puisque ce fichier se trouve dans le répertoire de travail de la session R. Dans tous les exemples suivants, seul le nom du fichier sera fourni. 

Les autres arguments de la fonction `read.table` doivent être adaptés selon le formatage du fichier à lire (voir la [fiche d'aide de la fonction `read.table`](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html)). Dans l'exemple ci-dessus, est-ce que toutes les valeurs par défaut des arguments convenaient vraiment? Jetons un coup d'oeil à l'objet obtenu.

```{r explo_import_texte_1}
data_ex_txt
str(data_ex_txt)
```

Il s'agit d'un data frame. La fonction `read.table` retourne toujours un objet de ce type. 

Nous pouvons tout de suite remarquer un problème avec ce data frame. Le nom des variables a été interprété comme une observation. Il faudrait utiliser l'argument `header` pour indiquer que la première ligne du fichier contient les noms des variables. 

```{r import_texte_2}
data_ex_txt <- read.table("data_ex.txt", header = TRUE)
str(data_ex_txt)
```

La première variable, `de1`, a été correctement lu, mais il y a un problème avec la deuxième variable, `de2`. Elle contient des données de type caractères, alors qu'il s'agit d'une variable numérique (le résultat d'un lancer de dé). Afin de pouvoir faire des calculs numériques sur cette variable, elle doit être stockée dans un vecteur (= colonne du data frame) de valeurs numériques. R a cru que les valeurs dans cette colonne étaient de type caractère à cause de la valeur manquante représentée par un point. L'argument `na.strings` de `read.table` indique à R les chaînes de caractères à interpréter comme des valeurs manquantes. Par défaut, `na.strings` prend la valeur `"NA"`. Il faut donc changer la valeur de cet argument comme suit.

```{r import_texte_3}
data_ex_txt <- read.table("data_ex.txt", header = TRUE, na.strings = ".")
str(data_ex_txt)
```

Nous avons réglé le problème de lecture de la deuxième colonne. Attardons-nous maintenant à la dernière colonne. Elle est enregistrée dans un vecteur de chaînes de caractères. Si nous avions préféré que `read.table` transforme les colonnes contenant des valeurs caractères en facteur, il aurait fallu assigner la valeur `TRUE` à l'argument `stringsAsFactors`. Avant sa version 4.0.0, R avait ce comportement par défaut. Le nouveau comportement par défaut est cependant bien ce que nous désirons ici.

Nous avons illustré ici deux arguments de la fonction `read.table`. Elle en possède plusieurs autres, à adapter selon le fichier à lire. 


### Arguments de la fonction `read.table`

Voici un résumé des arguments les plus utiles de la fonction `read.table`. Chaque argument est en lien avec une question que l'utilisateur doit se poser lors de la lecture d'un fichier de données.

- Est-ce que les noms des variables sont sur la première ligne ?
    + Si oui, utiliser `header = TRUE`, sinon `header = FALSE`. 
    + Par défaut `header = FALSE`, sauf si la première ligne contient un élément de moins que les lignes suivantes. Dans ce cas, R considère que la première ligne contient les noms des variables et que les lignes suivantes contiennent les observations précédées d'un nom de ligne.
    
- Quel caractère sépare les valeurs ?
    + Fournir ce caractère comme valeur à l'argument `sep`. 
    + Par défaut `sep = ""`, ce qui signifie que le séparateur est un «&nbsp;blanc&nbsp;», soit un espace ou plus, une tabulation, une fin de ligne ou un retour de chariot.
    
- Quel est le symbole décimal ?
    + Fournir ce symbole sous forme de chaîne de caractères à l'argument `dec`. 
    + Par défaut `dec = "."`

-	Comment sont représentées les valeurs manquantes ?
    + Fournir cette représentation sous forme de chaîne de caractères à l'argument `na.strings`. 
    + Par défaut `na.strings = "NA"`.

-	Est-ce que certaines valeurs sont encadrées ? Si oui, par quel symbole ?
    + S'il y a des valeurs encadrées, fournir à l'argument `quote` une chaîne de caractère contenant une concaténation de tous les caractères utilisés pour encadrer ces valeurs.
    + Par défaut `quote = "\"'"`, ce qui signifie qu'un guillemet double ou simple indique le début ou la fin d'une valeur. La barre oblique inversée (`\`) devant le deuxième `"` dans `"\"'"` est nécessaire afin que ce `"` ne soit pas interprété comme la fin de la chaîne de caractères fournie en valeur d'entrée à `quote`.  
    
-	Est-ce qu’il y a des caractères spéciaux, par exemple des accents ? Si oui, quel encodage est utilisé ?
    + Un des encodages les plus courants est `UTF-8`. En cas de problèmes avec des accents mal lus, essayer l'argument `encoding = "UTF-8"`. Ça pourrait régler le problème.
    + Par défaut l'encodage est supposé inconnu.
    
-	Est-ce que les données ou les noms des variables débutent à la ligne 1 ?
    + Si ce n'est pas le cas, fournir à l'argument `skip` le nombre de lignes à ne pas lire au début du fichier.
    + Par défaut `skip = 0`, donc aucune ligne n'est sautée. 
    
- Est-ce que les données se terminent à la dernière ligne non vide ?
    + Si ce n'est pas le cas, fournir à l'argument `nrows` le nombre de lignes à lire.
    + Par défaut la lecture des lignes se termine à la fin du fichier.
    
-	Est-ce que le fichier contient des commentaires ? Si oui, quel signe précède ces lignes ?
    + Fournir à `comment.char` un seul caractère, soit celui indiquant que le reste d'une ligne contient un commentaire. Pour empêcher la détection de commentaires, utiliser `comment.char = ""`.
    + Par défaut `comment.char = "#"`.

-	Est-ce que les colonnes contenant des chaînes de caractères doivent être converties en facteurs ?
    + Si oui, utiliser `stringsAsFactors = TRUE`, sinon `stringsAsFactors = FALSE`.
    + Par défaut `stringsAsFactors = FALSE`.
    
-	Est-ce que les données dans les différentes colonnes sont toutes du bon type ?
    + Si ce n'est pas le cas, les types désirés peuvent être spécifiés avec l'argument `colClasses`.
    + Par défaut R déduit des types de données en fonction du contenu des colonnes.

Tous les détails ainsi que la description des autres arguments de la fonction `read.table` sont dans la [fiche d'aide de la fonction `read.table`](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html). 


### Format CSV

Le format CSV est un format texte de données assez usuel. CSV signifie *Comma Separated Values*. En fait, dans un fichier CSV, les valeurs sont séparées par des virgules ou des points-virgules. Deux séparateurs consécutifs signifient qu'une valeur est manquante. Le fichier `data_ex.csv` est un exemple de fichier sous ce format. Il a l'allure suivante.

```
"de1";"de2";"lanceur"
2;1;"Luc"
3;4;"Luc"
4;2;
1;3;"Luc"
2;5;"Luc"
3;4;"Kim"
5;;"Kim"
6;2;"Kim"
5;5;"Kim"
4;3;"Kim"
```

La fonction `read.csv2` est tout indiquée pour importer ce fichier puisque la valeur par défaut de son argument `sep` est `";"`. Cette fonction appelle en fait la fonction `read.table`, mais avec des valeurs par défaut différentes pour les arguments. Ce type de fonction est appelé fonction enveloppe (en anglais *wrapper*). La fonction `read.table` possède 4 fonctions enveloppe&nbsp;: `read.csv`, `read.csv2`, `read.delim` et `read.delim2`.

Les arguments de la fonction `read.csv2` ont-ils toutes les bonnes valeurs par défaut pour importer le fichier `data_ex.csv`?

```{r}
data_ex_csv <- read.csv2("data_ex.csv")
str(data_ex_csv)
```

Ici, la première ligne a correctement été interprétée comme le nom des variables, parce que l'argument `header` de `read.csv2` prend par défaut la valeur `TRUE`. Aussi, la valeur manquante a été bien interprétée pour la variable numérique, mais pas pour la variable catégorique. Utilisons donc l'argument `na.strings` comme suit pour faire correctement l'importation.

```{r}
data_ex_csv <- read.csv2("data_ex.csv", na.strings = "")
str(data_ex_csv)
```


### Fichier texte volumineux

La fonction `read.table` (et ses fonctions enveloppe) arrive en principe à lire n'importe quel fichier texte de données. Elle peut cependant être lente pour lire des fichiers volumineux. Dans ce cas, il est plus pratique de se tourner vers une alternative plus rapide.

#### Package `readr`

\mbox{}

Le package [`readr`](https://readr.tidyverse.org/) du [`tidyverse`](https://www.tidyverse.org/) offre différentes fonctions pour lire des fichiers textes, selon leur format. Par exemple, il offre la fonction [`read_csv2`](https://readr.tidyverse.org/reference/read_delim.html), similaire à la fonction `read.csv2` du R de base. Voici un exemple d'utilisation de cette fonction.

```{r message = FALSE}
library(readr)
data_ex_csv_readr <- read_csv2("data_ex.csv")
str(data_ex_csv_readr)
```

L'objet retourné par les fonctions de `readr` est un [tibble](https://stt4230.rbind.io/manipulation_donnees/structures_r/#tibbles). Remarquons que la fonction `read_csv2` a, par défaut, correctement interprété les valeurs manquantes et elle n'a pas stocké les données de type caractère dans un facteur. Des attributs ont été ajoutés au tibble pour spécifier les types des colonnes.



#### Package `data.table`

\mbox{}

Bien que les fonctions du package `readr` tendent à être plus rapides que la fonction `read.table`, une autre fonction est capable d'être encore plus rapide&nbsp;: la fonction [`fread`](https://rdatatable.gitlab.io/data.table/reference/fread.html) du package [`data.table`](https://rdatatable.gitlab.io/data.table/). Voici un exemple d'utilisation de cette fonction.

```{r message = FALSE}
library(data.table)
data_ex_csv_fread <- fread("data_ex.csv", na.strings = "")
str(data_ex_csv_fread)
```

L'objet retourné par la fonction `fread` est un [data table](https://stt4230.rbind.io/manipulation_donnees/structures_r/#data-tables). Tout comme la fonction `read.table`, la fonction `fread` possède un argument nommé `na.strings`, que nous avons du spécifier afin que la valeur manquante pour la variable catégorique soit bien interprétée. La fonction `fread` a, comme `read.table` et `read_csv2`, stocké par défaut dans un vecteur les données de types caractères.


## Format JSON

Ce ne sont pas toutes les données qui conviennent au format «&nbsp;tableau de données&nbsp;» avec des observations en lignes et des variables en colonnes. Le format JSON n'est pas contraint à des données de ce type. Un fichier JSON est en fait un fichier texte, contenant des paires attributs - valeurs. Par exemple, les données utilisées dans les exemples précédents ont l'allure suivante en format JSON.


```
[
	{
	  "de1": 2,
	  "de2": 1,
	  "lanceur": "Luc"
	},
	{
	  "de1": 3, 
	  "de2": 4, 
	  "lanceur": "Luc"
	},
	{
	  "de1": 4, 
	  "de2": 2, 
	  "lanceur": null
	},
	{
	  "de1": 1,
	  "de2": 3, 
	  "lanceur": "Luc"
	},
	{
	  "de1": 2, 
	  "de2": 5, 
	  "lanceur": "Luc"
	},
	{
	  "de1": 3, 
	  "de2": 4, 
	  "lanceur": "Kim"
	},
	{
	  "de1": 5,
	  "de2": null,
	  "lanceur": "Kim"
	},
	{
	  "de1": 6,
	  "de2": 2, 
	  "lanceur": "Kim"
	},
	{
	  "de1": 5, 
	  "de2": 5, 
	  "lanceur": "Kim"
	},
	{
	  "de1": 4,
	  "de2": 3,
	  "lanceur": "Kim"
	}
]
```


Le fichier comporte un élément pour chacune des 10 observations. Pour chaque observation, la valeur prise pour chacune des variables est spécifiée. Ce format est plus souple qu'un tableau de données, car la valeur d'une variable pour une observation pourrait être de n'importe quelle dimension, plutôt que d'être une seule donnée. Remarquons que dans le format JSON, une donnée manquante est représentée par `null` plutôt que `NA`.

Aucune fonction de l'installation de base de R ne permet de lire ce format de fichier. Cependant, quelques packages offrent des fonctions pour ce faire. C'est le cas de la fonction `fromJSON` du [package `jsonlite`](https://CRAN.R-project.org/package=jsonlite). Voici un exemple d'utilisation de cette fonction.

```{r}
library(jsonlite)
data_ex_json <- fromJSON("data_ex.json")
str(data_ex_json)
```

La fonction `fromJSON` a converti le contenu du fichier `data_ex.json` en data frame. 


## Fichier EXCEL

Afin de lire en R des données provenant d'un fichier EXCEL, une première option est d’enregistrer le fichier dans un format texte, puis de l'importer en R avec les moyens vus précédemment. Cette procédure n'est cependant pas automatique. Il existe quelques packages R offrant des fonctions pour lire directement dans un fichier EXCEL. Un de ces packages est [`readxl`](https://readxl.tidyverse.org). Supposons que nous voulons importer en R le fichier EXCEL `data_ex.xlsx` ayant l'allure suivante.

```{r echo = FALSE, out.width = "50%", fig.align = 'center', fig.pos='H', eval=knitr::is_html_output()}
knitr::include_graphics("../fig/data_ex_xlsx.png")
```
```{r echo = FALSE, eval=knitr::is_latex_output()}
knitr::asis_output("\\begin{center}\\includegraphics[width=0.5\\linewidth]{fig/data_ex_xlsx.png}\\end{center}")
```


Nous pourrions procéder comme suit.

```{r importEXCEL}
library(readxl)
data_ex_xlsx <- read_excel("data_ex.xlsx")
str(data_ex_xlsx)
```

<!---
Retiré, car je crois qu'il est maintenant possible de faire avec readxl et openxlsx ce qu'on peut faire avec XLConnect, avec l'avantage de ne pas dépendre de Java

Le [package `XLConnect`](https://CRAN.R-project.org/package=XLConnect) offre aussi des fonctions pour lire des fichiers EXCEL. Il est plus puissant que `readxl`. Il permet de lire dans des cases précises d'un fichier EXCEL, ainsi que d'écrire dans un fichier EXCEL. Cependant, ce package dépend d'un autre logiciel&nbsp;: Java. Il faut donc avoir une installation du logiciel Java sur son ordinateur pour utiliser ce package. Il faut en outre avoir la version de Java avec un nombre de bits correspondant au nombre de bits de la version de R utilisée. Afin d'optimiser la mémoire accessible au cours d'une session R, je conseille d'utiliser R 64-bits à ceux qui travaillent sous un système d'exploitation 64-bits. Par contre, il est courant d'avoir seulement la version 32-bits de Java sur son ordinateur, même si le système d'exploitation de celui-ci fonctionne en 64-bits. C'est dû au fait que le logiciel Java est utilisé principalement par les navigateurs web, qui fonctionnent souvent en 32-bits, même sous un système d'exploitation 64-bits. Pour installer la version 64-bits de Java en plus de la version 32-bits, il faut télécharger un installateur pour cette version de Java sur la page web suivante&nbsp;:  
https://www.java.com/fr/download/manual.jsp
--->

Un des grands avantages de `readxl` comparativement à d'autres packages offrant des fonctions pour lire des fichiers EXCEL est qu'il ne dépend pas d'un autre logiciel. Plusieurs de ces packages requièrent une installation du logiciel Java.


## Données publiées sur internet

Le web est rempli de données de toutes sortes. Pour lire des données stockées dans un fichier téléchargeable sur une page web, il suffit de d'abord télécharger le fichier, puis de le lire avec un des moyens présentés précédemment. Il est aussi possible de donner comme argument `file` à une fonction de la famille `read.table` directement une URL (adresse web). 

La plupart des données disponibles sur le web ne sont cependant pas distribuées dans un fichier. Souvent, elles sont simplement présentées sous forme de tableaux dans des tables HTML. Une façon d'importer en R les données d'une table HTML serait de copier/coller le contenu de la table dans un fichier (texte ou autre), puis d'importer ce fichier en R. Si la table HTML en question provient d'une page sur un Wiki, tel que Wikipédia, le site web https://wikitable2csv.ggor.de/ facilite même cette tâche en créant des fichiers au format CSV contenant les données dans les tables HTML.

Ces façons de procéder ne sont cependant pas automatiques. Certains packages R permettent d'éviter les étapes intermédiaires manuelles et permettent de lire directement dans une table HTML. Il est ainsi facile d'accéder à un très grand nombre de données en R. C'est une forme de ce qui est appelé en anglais le «&nbsp;*web harvesting*&nbsp;» ou «&nbsp;*web scraping*&nbsp;».

Voici un exemple de lecture de données directement à partir d'une table HTML avec le [package `rvest`](https://rvest.tidyverse.org/).

```{r HTML, message = FALSE}
library(rvest)
url <- "https://en.wikipedia.org/wiki/List_of_highest-grossing_films"
page <- read_html(url)
tables <- html_table(page, fill = TRUE)
boxoffice <- tables[[1]]
str(boxoffice)
```

```{r include = FALSE, eval = FALSE}
# À utiliser seulement s'il y a un problème avec le code ci-dessus
boxoffice <- readRDS("C:/coursR/boxoffice_20200113.rds")
str(boxoffice)
```

La fonction `read_html` lit tout le code HTML d'une page web. Cette lecture fonctionnera évidemment à la condition d'être connecté à internet. La fonction `html_table` en extrait les tables et les converties en data frames. Pour finir, il ne reste plus qu'à extraire la table voulue parmi toutes les tables lues.

Le data frame obtenu dans le code précédent, nommé `boxoffice`, contient les recettes des films ayant générés le plus de revenus dans les cinémas américains, telles que présentées sur la page web https://en.wikipedia.org/wiki/List_of_highest-grossing_films le 18 janvier 2021.

Mentionnons finalement qu'il existe de plus en plus de packages R pour aller chercher rapidement, à partir de R, des données ouvertes publiées sur des sites web. Par exemple, le [package `gtrendsR`](https://github.com/PMassicotte/gtrendsR) permet d'importer en R des données provenant de [Google trends](https://trends.google.ca). Ce genre de possibilité ne sera pas illustrée ici, mais la page web suivante énumère des packages utiles pour aller chercher des données sur divers sites web&nbsp;:  
https://cran.r-project.org/web/views/WebTechnologies.html.

## Vérification de l'importation

Une leçon importante à retenir de tous les exemples d'importation présentés dans ce document est qu'il faut toujours vérifier que l'objet R dans lequel nous avons importé des données contient les bonnes données et sous le bon format. Si ce n'est pas le cas, la commande d'importation de données doit être corrigée. Plusieurs tentatives sont parfois nécessaires afin d'arriver à effectuer correctement l'importation.

Voici une liste de vérifications qu'il est toujours bon d'effectuer après une importation en R, dans un data frame, de données sous forme de tableau avec des observations en lignes et des variables en colonnes.

-	Est-ce que le nombre de variables (colonnes) dans le data frame est le même que le nombre de variables dans le fichier ?
-	Est-ce que le nombre d'observations (lignes) dans le data frame est le même que le nombre d'observations dans le fichier ?
-	Est-ce que, pour chacune des variables du jeu de données, le type de données dans le data frame correspond au type de données dans le fichier ?
-	Si le jeu de données n'est pas de très petite taille, il est impossible de vérifier une à une toutes les observations. Cependant, pour une observation (ligne) sélectionnée au hasard (ou plus d'une si vous désirez être encore plus rigoureux), est-ce que les valeurs de cette observation dans le data frame sont identiques aux valeurs de cette observation dans le fichier ?
-	Est-ce que les données manquantes sont bien représentées dans data frame par la constante `NA`, et ce, dans les colonnes de tout type ?

Si vous répondez oui à toutes ces questions, votre importation de données a de bonnes chances d'avoir été effectuée correctement.

***

# Écriture dans des fichiers 

En cours d'analyse, il n'est pas rare d'obtenir des résultats dont il est préférable de conserver une copie dans un fichier externe. Ce fichier peut facilement être partagé avec d'autres ou importé dans un autre logiciel pour la poursuite des analyses selon les besoins. Il faut alors demander à R de créer un fichier et d'écrire dans celui-ci.

Exporter les données stockées dans un objet R peut aussi être utile simplement pour aider à les visualiser. Il est vrai que R offre la possibilité de voir le contenu de matrices ou de data frames dans un chiffrier ressemblant à une feuille EXCEL. Ce chiffrier peut être ouvert en appelant la [fonction `View`](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/View.html) ou en cliquant sur un objet dans la sous-fenêtre *Environment* de RStudio. Cependant, pour certaines structures de données non représentables sous forme de tableau, exporter les données dans un fichier externe demeure la meilleure option pour les visualiser.

Pour les exemples à venir, reprenons le data frame `data_ex` et voyons comment exporter son contenu.


## Fichier texte

Le format de fichier le plus universel pour exporter des données est le format texte. Un grand nombre de logiciels peuvent lire ce format. Les fonctions de base en R pour écrire dans un fichier texte sont `write` et `write.table`. Nous verrons ici seulement comment utiliser `write.table`, qui est plus adaptée à l'exportation de jeux de données. Par exemple, exportons le contenu du data frame `data_ex` dans le fichier texte `data_ex_export.txt`

```{r exportTexte, eval = FALSE}
write.table(data_ex, file = "data_ex_export.txt")
```

Il faut spécifier à la fonction l'objet dans lequel se trouvent les données à exporter (typiquement une matrice ou un data frame), ainsi que le fichier dans lequel écrire les données. 
Tout comme son équivalent pour lire des données `read.table`, la fonction `write.table` possède plusieurs arguments permettant de contrôler notamment le symbole de décimale (`dec`), le symbole représentant les valeurs manquantes (`na`), le séparateur entre les différentes colonnes (`sep`), la présence ou non des noms des lignes ou des colonnes (`row.names` et `col.names`), etc. 

Il existe aussi deux fonctions enveloppe à la fonction `write.table` pour les formats CSV, nommées `write.csv` et `write.csv2`.


## Fichier JSON

Pour exporter les données dans un data frame en format JSON avec le package `jsonlite`, il faut d'abord transformer les données au format JSON avec la fonction `toJSON`. Ensuite, l'objet obtenu doit être écrit dans un fichier externe avec la fonction `write` du R de base.

```{r eval = FALSE}
data_ex_json <- toJSON(data_ex, pretty = TRUE)
write(data_ex_json, "data_ex_export.json")
```

## Fichier EXCEL

Le [package `openxlsx`](https://ycphs.github.io/openxlsx/index.html) offre des fonctions pour exporter des données stockées dans un objet R dans un fichier EXCEL. Par exemple, le contenu du data frame `data_ex` peut être écrit dans un fichier EXCEL comme suit.

```{r, eval = FALSE}
library(openxlsx)
write.xlsx(data_ex, file = "data_ex_export.xlsx")
```


## Enregistrement d'objets R dans un fichier externe

R propose aussi ses formats de fichiers pour enregistrer des objets entiers, en conservant à la fois les données contenues dans les objets et les structures des objets.

**Formats binaires**  

Une image de session est l'ensemble des objets dans l'environnement de travail d'une session R. Lors de la fermeture de R, il nous est proposé par défaut d'enregistrer cette image. La fonction `save.image` peut aussi être utilisée en tout temps pour enregistrer cette image.

```{r saveObjects, eval = FALSE}
save.image(file = "image.RData")
```

La fonction `save` permet pour sa part d'enregistrer un ou des objets en particulier, par exemple&nbsp;:

```{r eval = FALSE}
save(data_ex, de_1, file = "deux_obj.rda")
save(data_ex, file = "data_ex.rda")
```

R offre aussi un format binaire alternatif pour enregistrer un seul objet, sans inclure le nom de l'objet dans le fichier (contrairement aux fonctions précédentes). Il s'agit du format .rds, obtenu avec la fonction `saveRDS`.

```{r eval = FALSE}
saveRDS(data_ex, file = "data_ex.rds")
```

L'utilisateur peut en réalité donner les extensions de son choix aux fichiers. Il est cependant recommandé d'utiliser les extensions suivantes&nbsp;:

- .RData ou .rda pour un objet créé avec les fonctions `save.image` ou `save`, 
- .rds pour un fichier créé avec la fonction `saveRDS`.

Ainsi, il est plus facile de se souvenir du format exact du fichier et de la fonction à utiliser pour charger le fichier lors de sessions futures (voir plus loin).


**Formats texte**

Il est aussi possible d'enregistrer des objets R sous un format texte avec `dump` ou `dput`. La fonction `dump` permet d'enregistrer plus d'un objet et les noms des objets sont inclus dans le fichier (comme pour `save` et `save.image`). La fonction `dput` ne permet d'enregistrer qu'un seul objet et son nom n'est pas inclus dans l'objet (comme pour `saveRDS`). Cependant, selon la documentation de R, l'utilisation des formats binaires est plus efficace et fiable.


## Écriture de sorties R dans un fichier externe

Finalement, il est possible d'envoyer les résultats de nos commandes dans un fichier texte externe plutôt que dans la console grâce aux fonctions `capture.output` et `sink`.

```{r saveOutput, eval = FALSE}
capture.output(summary(data_ex), file = "data_ex_summary.out")
```

```{r eval = FALSE}
sink("data_ex.out")
data_ex
colMeans(data_ex[, 1:2], na.rm = TRUE)
sink()
```

***

# Chargement d’objets R provenant d’un fichier externe 

**Formats binaires**

Pour charger en R des objets R stockés dans un fichier au format .RData, .rda ou .rds, il faut utiliser la fonction

- `load`&nbsp;: pour les fichiers produits avec la fonction `save` ou `save.image` (format .RData ou .rda, peut contenir plus d'un objet, les noms des objets sont inclus dans le fichier);
- `readRDS`&nbsp;: pour les fichiers produits avec la fonction `saveRDS` (format .rds, ne peut contenir qu'un seul objet, le nom de l'objet n'est pas inclus dans le fichier); la fonction `readRDS` doit être utilisée avec une assignation pour stocker le résultat de l'importation dans un objet.

Voici deux exemples d'appel de ces fonctions.

```{r readObjects, eval = FALSE}
load("deux_obj.rda")
```

```{r eval = FALSE}
data_ex_copie <- readRDS("data_ex.rds")
```

La fonction `load` ajoute des objets dans l'environnement de travail. Si des objets portant les mêmes noms que ceux à importer sont déjà présents dans l'environnement de travail, ils sont remplacés sans même qu'un avertissement ne soit émis. Avec cette fonction, il y a donc un risque d'écraser sans s'en rendre compte des objets présents dans notre environnement de travail.

**Rappel**&nbsp;: Si le répertoire de travail par défaut de R contient un fichier nommé `.RData`, les objets dans ce fichier seront automatiquement chargés en R lors d'une ouverture de session. *Pour empêcher ce chargement automatique, il faut effacer ce fichier `.RData` .*


***

# Résumé

<p style="font-size:110%">
**Répertoire de travail et écriture de chemins d'accès à des fichiers**
</p>

Répertoire de travail = emplacement par défaut dans le système de fichier de notre ordinateur utilisé dans la session R (emplacement supposé par R lorsque cette information n’est pas spécifiée)

- `getwd`&nbsp;: affiche le chemin d'accès au répertoire de travail,
- `setwd`&nbsp;: permet de changer de répertoire de travail.

Règles à respecter dans l'écriture de chemins d'accès à des fichiers&nbsp;:

- **pas de `\`**&nbsp;: seuls `/` et `\\` sont acceptés pour séparer les éléments d'un chemin d'accès;
- toujours inclure l'**extension** du fichier;
- encadrer le chemin de **guillemets**.

Exemple&nbsp;:
```{r eval = FALSE}
"C:/coursR/data_ex.txt"
```


\vspace{6pt}
<p style="font-size:110%">
**Lecture (importation) dans des fichiers**
</p>

Format à lire  Fonctions de lecture
-------------  ----------------------
texte          `read.table` (`.csv`, `.csv2`, `.delim`, `.delim2`)
&nbsp;         `read_table` (`_csv`, `_delim`, etc.;  package `readr`)
&nbsp;         `fread` (package `data.table`)
JSON           `fromJSON` (package `jsonlite`)
EXCEL          `read_excel` (package `readxl`)
table HTML     `read_html` + `html_table` (package `rvest`)

<!--
\begin{longtable}[]{@{}ll@{}}
\toprule
Format à lire & Fonctions de lecture\tabularnewline
\midrule
\endhead
texte & \texttt{read.table} (\texttt{.csv}, \texttt{.csv2},
\texttt{.delim}, \texttt{.delim2})\tabularnewline
 & \texttt{read\_table} (\texttt{\_csv}, \texttt{\_delim}, 
 etc.; package \texttt{readr})\tabularnewline
 & \texttt{fread} (package \texttt{data.table})\tabularnewline
JSON & \texttt{fromJSON} (package \texttt{jsonlite})\tabularnewline
EXCEL & \texttt{read\_excel} (package \texttt{readxl})\tabularnewline
table HTML & \texttt{read\_html} + \texttt{html\_table} (package
\texttt{rvest})\tabularnewline
\bottomrule
\end{longtable}
-->

Des fonctions R existent pour importer des données sous plusieurs autres formats (voir références dans les notes). $\rightarrow$ non couvert dans le cours

**À garder en tête**&nbsp;: Il est conseillé de toujours vérifier que les données importées sont les bonnes et sous le bon format. Si ce n’est pas le cas, la commande d’importation de données doit être corrigée.


\vspace{6pt}
<p style="font-size:110%">
**Écriture (exportation) dans des fichiers**
</p>

Élément(s) à exporter   | Fonction d'écriture                          
--------------------- | ----------------------------------------------------
données et (optionnel)  | format texte (recommandé)&nbsp;: `write.table` (`.csv`, `.csv2`)                   
métadonnées             | format JSON&nbsp;: `toJSON` (package `jsonlite`) + `write`
&nbsp;                  | format EXCEL&nbsp;: `write.xlsx` (package `openxlsx`)
&nbsp; | &nbsp;
+ structure complète    | `save.image`, `save` (objet(s) + leur(s) nom(s)) 
(objet R intact)        | `saveRDS` (un seul objet, sans son nom)
&nbsp; | &nbsp;
sorties R               | `capture.output`, 
&nbsp;                  | `sink` 

<!--
\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.31\columnwidth}\raggedright
Élément(s) à exporter\strut
\end{minipage} & \begin{minipage}[b]{0.63\columnwidth}\raggedright
Fonction d'écriture\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.31\columnwidth}\raggedright
données et (optionnel)\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- format texte (recommandé)&nbsp;: \texttt{write.table} (\texttt{.csv},
\texttt{.csv2})\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
métadonnées\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- format JSON&nbsp;: \texttt{toJSON} (package \texttt{jsonlite}) +
\texttt{write}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
~\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- format EXCEL&nbsp;: \texttt{write.xlsx} (package \texttt{openxlsx})\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
---------------------------\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
------------------------------------------------------\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
+ structure complète\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- \texttt{save.image}, \texttt{save} (objet(s) + leur(s) nom(s))\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
(objet R intact)\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- \texttt{saveRDS} (un seul objet, sans son nom)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
---------------------------\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
------------------------------------------------------\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
sorties R\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- \texttt{capture.output},\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.31\columnwidth}\raggedright
~\strut
\end{minipage} & \begin{minipage}[t]{0.63\columnwidth}\raggedright
- \texttt{sink}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}
-->


\vspace{6pt}
<p style="font-size:110%">
**Chargement d’objets R provenant d'un fichier externe**
</p>

Fonction pour charger en R des objets stockés dans un fichier externe&nbsp;:

- fichier créé avec `save.image` ou `save` (typiquement extension .RData ou .rda)&nbsp;: `load`;
- fichier créé avec `saveRDS`&nbsp;: `readRDS`, accompagnée d'une assignation à un nom pour enregistrer l'objet dans l'environnement de travail.

***

# Références {-}

Documentation officielle de R&nbsp;:  

- R Core Team (2020). *R Data Import/Export*. R version 4.0.3. URL http://cran.r-project.org/doc/manuals/r-release/R-data.html

Documentation des packages utilisés&nbsp;:

- package `readr`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=readr
    + documentation du package&nbsp;: https://readr.tidyverse.org/
    + chapitre 11 du livre&nbsp;: Grolemund, G. et Wickham, H. (2016). *R for Data Science*. O'Reilly Media, Inc.&nbsp;: https://r4ds.had.co.nz/data-import.html
- package `data.table`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=data.table
    + documentation du package&nbsp;: https://rdatatable.gitlab.io/data.table/
- package `jsonlite`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=jsonlite
- package `readxl`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=readxl 
    + documentation du package&nbsp;: https://readxl.tidyverse.org/
- package `rvest`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=rvest 
    + documentation du package&nbsp;: https://rvest.tidyverse.org/
- package `openxlsx`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=openxlsx
    + documentation du package&nbsp;: https://ycphs.github.io/openxlsx/index.html

Autres bonnes sources d'information sur le web&nbsp;:

- https://www.datacamp.com/community/tutorials/r-data-import-tutorial
- https://en.wikibooks.org/wiki/R_Programming/Importing_and_exporting_data
- https://themockup.blog/posts/2020-12-13-extracting-json-from-websites-and-public-apis-with-r/

\vspace{6pt}
<p style="font-size:110%">
**Pour aller plus loin en importation et exportation de données**
</p>

- packages utiles pour aller chercher des données ouvertes publiées sur le web&nbsp;:
    + https://CRAN.R-project.org/view=WebTechnologies
    
- package `foreign`, `Hmisc` ou `haven` pour des jeux de données dans un format propre à un autre logiciel statistique (ex. formats SAS, SPSS, etc.) et autres formats&nbsp;: 
    + http://www.statmethods.net/input/importingdata.html
    + http://www.statmethods.net/input/exportingdata.html 
    + https://CRAN.R-project.org/package=haven
    
- communication avec des bases de données&nbsp;:
    + https://CRAN.R-project.org/view=Databases
    + https://db.rstudio.com/
    + https://datacarpentry.org/R-ecology-lesson/05-r-and-databases.html
    
- utilisation de connexions pour accéder à des fichiers&nbsp;:  
    + Chapitre 10 de Matloff, N. (2011). *The Art of R Programming&nbsp;: A Tour of Statistical Software Design*. No Starch Press.

