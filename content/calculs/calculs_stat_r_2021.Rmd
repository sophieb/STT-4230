---
title: "Calculs statistiques en R"
author: "Sophie Baillargeon, Université Laval"
date: "2021-01-25"
weight: 2
slug: "calculs_stat_r"
lastmodifierdisplayname: "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document: 
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    number_sections: yes
    highlight: tango
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---

`r knitr::opts_chunk$set(fig.align = 'center', fig.show = 'hold')`

***

*Note préliminaire&nbsp;: Lors de leur dernière mise à jour, ces notes ont été révisées en utilisant R version 4.0.3 et le package `broom` version 0.7.3. Pour d'autres versions, les informations peuvent différer.*

***

R est un environnement spécialisé dans les calculs statistiques. Voyons comment réaliser de tels calculs en R, qu'il s'agisse de production de statistiques descriptives, de manipulation des distributions de probabilité, de génération de nombres pseudo-aléatoires, de réalisation de tests ou d'ajustement de modèles.

***

# Statistiques descriptives

Les fonctions permettant de calculer des statistiques descriptives en R sont très nombreuses. Les principales sont présentées ici, mais il en existe d'autres. Le tableau suivant classe les fonctions mentionnées ci-dessous selon le type de mesure calculée (mesure de position, de tendance centrale, de dispersion ou de fréquences) et selon le type de fonctionnement de la fonction (calcul vectoriel, données combinées en une ou plusieurs valeurs).

Calcul | opère de façon vectorielle | combine, retourne une valeur | combine, retourne valeur(s) | combine, retourne un vecteur|
-----------|-------|-------------|-----------|----------|
mesure de position | [`pmin`, `pmax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html) | [`min`, `max`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html), [`which.min`, `which.max`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html) | [`range`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html), [`quantile`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/quantile.html), [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html) | [`cummin`, `cummax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html), [`rank`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html) 
tendance centrale | | [`mean`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/mean.html), [`median`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/median.html) | [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html) | |
dispersion | | [`sd`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/sd.html), [`IQR`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/IQR.html), [`mad`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/mad.html) | [`var`, `cov`, `cor`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html) | |
fréquences | | | [`table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html), [`ftable`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ftable.html), [`xtabs`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/xtabs.html), [`summary`]((https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html)) | |



## Fonctions retournant une seule statistique

Certaines fonctions de calcul de statistiques descriptives retournent en sortie une seule valeur. C'est le cas des fonctions suivantes&nbsp;:

- [mesures de position](https://fr.wikipedia.org/wiki/Indicateur_de_position)&nbsp;: [`min`, `max`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html);
- [mesures de tendance centrale](https://fr.wikipedia.org/wiki/Indicateur_de_tendance_centrale)&nbsp;: [`mean`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/mean.html), [`median`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/median.html);
- [mesure de dispersion](https://fr.wikipedia.org/wiki/Indicateur_de_dispersion)&nbsp;: [`sd`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/sd.html) ([écart-type](https://fr.wikipedia.org/wiki/%C3%89cart_type)), [`IQR`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/IQR.html) ([écart interquartile](https://fr.wikipedia.org/wiki/%C3%89cart_interquartile)), [`mad`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/mad.html) ([écart absolu médian](https://en.wikipedia.org/wiki/Median_absolute_deviation)).

Utilisons le [jeu de données `cars`](https://stat.ethz.ch/R-manual/R-patched/library/datasets/html/cars.html) du package `datasets` pour présenter quelques exemples. Ce jeu de données contient 50 observations de 2 variables numériques.

```{r}
str(cars)

# Moyenne des observations de la variable dist
mean(cars$dist)
```

Si l'objet en entrée a plus d'une dimension, la sortie est tout de même de longueur 1. Donc tous les éléments contenus dans l'objet sont mis en commun pour faire le calcul.
```{r}
max(cars)
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `which.max` et `which.min`**
</p>

Les fonctions `min`  et `max` retournent respectivement la valeur la plus petite et la valeur la plus grande parmi les éléments d'un objet. Les fonctions [`which.max` et `which.min`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html) retournent pour leur part la position dans l'objet du **premier** maximum ou minimum.  
```{r}
which.min(cars$speed)
```

Dans l'exemple précédent, il y a en fait deux observations qui prennent la valeur minimum de `min(cars$speed)`. La commande suivante permet de trouver la position de toutes les observations prenant la valeur minimale.

```{r}
which(cars$speed == min(cars$speed))
```


### Traitement des données manquantes et argument `na.rm`

Les fonctions `min`, `max`, `mean`, `median` et `sd`, ainsi que quelques autres fonctions vues dans ces notes, ont un argument en commun nommé `na.rm`. Cet argument sert à indiquer à la fonction comment agir en présence de données manquantes (`NA`). Par défaut, `na.rm` prend la valeur `FALSE` pour ces fonctions. Cette valeur signifie que les données manquantes ne doivent pas être retirées avant d'effectuer le calcul. Cependant, en présence de données manquantes, ces fonctions ne sont pas en mesure de calculer des statistiques. Par exemple, supposons que nous voulions calculer la médiane des données dans le vecteur suivant.

```{r}
x <- c(3, 6, NA, 8, 11, 15, 23)
```

Si nous ne retirons pas la donnée manquante, nous obtenons le résultat suivant.

```{r}
median(x)
```

Ce résultat s'explique par le fait que la valeur de la médiane dépend de toutes les observations, incluant l'observation manquante, qui est inconnue. La valeur de la médiane est donc elle aussi inconnue. Pour calculer plutôt la médiane des observations non manquantes, il faut donner la valeur `TRUE` à l'argument `na.rm` comme suit.

```{r}
median(x, na.rm = TRUE)
```

Notons que la [fonction `na.omit`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html) permet de retirer les observations manquantes d'un objet R. Si l'objet est un vecteur, les éléments contenant `NA` sont retirés.

```{r}
na.omit(x)
```

La fonction `na.omit` ajoute deux attributs à l'objet, dont un pour identifier les observations retirées. 

Remarquons que les deux commandes suivantes retournent le même résultat.

```{r}
median(x, na.rm = TRUE)
median(na.omit(x))
```


Si la fonction `na.omit` reçoit en entrée une matrice ou un data frame, elle retire toutes les lignes contenant au moins un `NA`, comme dans cet exemple&nbsp;:

```{r}
ex_jeu <- data.frame(x, y = c(2, NA, 8, 9, 6, NA, 2)); 
ex_jeu
na.omit(ex_jeu)
```



## Fonctions pouvant retourner plusieurs statistiques

D'autres fonctions peuvent retourner plus d'une statistique, notamment les fonctions suivantes&nbsp;:

- mesures de position&nbsp;: [`range`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html), [`quantile`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/quantile.html);
- résumé comprenant plusieurs mesures&nbsp;: [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html);
- variances, covariances et corrélations&nbsp;: [`var`, `cov`, `cor`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html).


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `range` et `quantile`**
</p>

La [fonction `range`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html) retourne à la fois le minimum est le maximum, comme dans cet exemple&nbsp;:
```{r range}
range(cars$speed)
```
Une façon simple d'obtenir l'étendue d'observations à partir de la sortie de la fonction `range` est de procéder comme suit&nbsp;:
```{r}
diff(range(cars$speed))
```

La [fonction `quantile`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/quantile.html) calcule des quantiles empiriques. Par défaut, elle retourne le minimum, le maximum et les quartiles, comme dans cet exemple&nbsp;:
```{r quantile}
quantile(cars$speed)
```
L'argument `probs` permet de demander n'importe quels quantiles. Dans l'exemple suivant, les premiers et neuvièmes déciles sont demandés.
```{r}
quantile(cars$speed, probs = c(0.1, 0.9))
```

**Remarque**&nbsp;: Il existe plusieurs façons de calculer des quantiles. La fonction `quantile` implémente 9 algorithmes de calcul de quantiles (voir [`help(quantile)`](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html)).


\vspace{6pt}
<p style="font-size:110%">
**Fonction `summary`**
</p>

La [fonction `summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html) retourne les statistiques suivantes selon l'entrée qu'elle reçoit&nbsp;: 

- vecteur numérique&nbsp;: minimum, premier quartile, médiane, moyenne, troisième quartile, maximum;
- facteur&nbsp;: fréquences des modalités (comme la fonction `table` vue plus loin);
- matrice ou data frame&nbsp;: la fonction `summary` est appliquée séparément à chacune des colonnes.

Utilisons le [jeu de données `Puromycin`](https://stat.ethz.ch/R-manual/R-patched/library/datasets/html/Puromycin.html) du package `datasets` pour présenter quelques exemples d'utilisation de la fonction `summary`. Ce jeu de données contient 23 observations de 3 variables, dont deux numériques et une catégorique, stockée sous forme de facteur.

```{r}
str(Puromycin)

# Vecteur numérique en entrée&nbsp;:
summary(Puromycin$rate)

# Facteur en entrée&nbsp;:
summary(Puromycin$state)

# Data frame entier en entrée&nbsp;:
summary(Puromycin)
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `var`, `cov` et `cor`**
</p>

La [fonction `var`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html) peut prendre en entrée un vecteur ou un objet à deux dimensions. Si elle reçoit en entrée un vecteur, elle calcule la variance empirique de toutes les valeurs, comme dans cet exemple&nbsp;: 
```{r var}
var(cars$speed)
```
Cependant, si elle reçoit en entrée une matrice ou un data frame de valeurs numériques, elle considère que chaque colonne contient les observations d'une variable aléatoire. Elle va calculer une [matrice de variances-covariances](https://fr.wikipedia.org/wiki/Covariance), comme dans cet exemple&nbsp;:
```{r}
var(cars)
```
La [fonction `cov`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html) fait exactement le même calcul par défaut. 
```{r}
cov(cars)
```
Elle peut cependant calculer des covariances de Kendall ou de Spearman (toutes deux des statistiques non paramétriques basées sur les rangs des observations) au lieu de la covariance classique de Pearson. La [fonction `cor`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html) calcule des corrélations plutôt que des covariances. Elle aussi peut utiliser les définitions de [Pearson](https://fr.wikipedia.org/wiki/Corr%C3%A9lation_(statistiques)) (par défaut), [Kendall](https://fr.wikipedia.org/wiki/Tau_de_Kendall) et [Spearman](https://fr.wikipedia.org/wiki/Corr%C3%A9lation_de_Spearman). Voici un exemple de calcul de matrice de corrélations de Spearman.
```{r}
cor(cars, method = "spearman")
```


## Fonctions retournant un vecteur de statistiques

Certaines fonctions, telles que les suivantes, retournent autant de statistiques qu'il y a d'éléments dans l'objet donné en entrée.

- mesures de position&nbsp;: [`cummin`, `cummax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html), [`pmin`, `pmax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html);
- rangs&nbsp;: [`rank`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html).

\vspace{6pt}
<p style="font-size:110%">
**Fonctions `cummin` et `cummax`**
</p>

Les [fonctions `cummin` et `cummax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html) calculent les minimums et les maximums cumulatifs. Comme nous pouvons le constater dans l'exemple suivant, la valeur en position `i` du vecteur retourné par une de ces deux fonctions est la valeur minimale ou maximale dans le sous-vecteur `x[1:i]`.
```{r}
cummin(x = c(-2, 4, -3, 4, 7, -6, 0))
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `pmin` et `pmax`**
</p>

Les [fonctions `pmin` et `pmax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html) calculent le minimum et le maximum par position, entre autant de vecteurs que désiré, comme dans l'exemple suivant. 
```{r}
pmax(
  c(-2, 4, -3, 4, 7, -6, 0), 
  c( 1, 2,  3, 4, 5,  6, 7),
  c( 5, 0, -2, 4, 5,  3, 3)
)
```
Ces fonctions sont utiles pour remplacer des valeurs par un seuil. Par exemple, l'instruction suivante permet de remplacer par zéro toute valeur négative contenue dans le vecteur en entrée.
```{r}
pmax(c(-2, 4, -3, 4, 7, -6, 0), 0)
```


\vspace{6pt}
<p style="font-size:110%">
**Fonction `rank`**
</p>

Certains tests statistiques non paramétriques utilisent des statistiques basées sur les rangs des observations. Voici un exemple d'obtention de ces rangs avec la [fonction `rank`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html).
```{r rank}
rank(c(-2, 4, -3, 4, 7, -6, 0))
```
Par défaut, en cas d'égalité, le rang moyen est utilisé. Pour changer cette option, il faut modifier la valeur de l'argument `ties.method`. Dans l'exemple suivant, le rang minimum est retourné en cas d'égalité.
```{r}
rank(c(-2, 4, -3, 4, 7, -6, 0), ties.method = "min")
```


## Calcul de fréquences

Les fonctions [`table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html), [`xtabs`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/xtabs.html) et [`ftable`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ftable.html) permettent de calculer des fréquences.

Voici un petit jeu de données pour illustrer l'utilisation de ces fonctions. Il contient des observations concernant 7 individus fictifs&nbsp;: la couleur de leurs yeux, la couleur de leurs cheveux et leur genre.
```{r}
sondage <- data.frame(
  yeux    = c("brun",    "brun",     "bleu",    "brun",    "vert",     "brun",    "bleu"    ),
  cheveux = c("brun",    "noir",     "blond",   "brun",    "brun",     "blond",   "brun"    ),
  genre   = c("féminin", "masculin", "féminin", "féminin", "masculin", "féminin", "masculin")
)
sondage
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `table`**
</p>

La [fonction `table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html) permet de compter le nombre d'occurrences de chacune des modalités d'une variable catégorique dans des données. Demandons, par exemple, à `table` de compter le nombre d'individus dans les données `sondage` classés dans chacune des catégories de couleurs de cheveux. 
```{r table}
table(sondage$cheveux)
```

La fonction `table` produit un tableau de fréquences à une variable si elle reçoit les observations d'une seule variable. Elle peut aussi produire des tableaux de fréquences croisées à deux variables ou plus.

```{r}
# Exemple de tableau de fréquences à deux variables (avec variables nommées)
table(yeux = sondage$yeux, cheveux = sondage$cheveux)
```

```{r}
# Exemple de tableau de fréquences à trois variables (data frame en entrée à table)
t3 <- table(sondage)
t3
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `ftable`**
</p>

La [fonction `ftable`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ftable.html) retourne un tableau de fréquences sous la forme d'une table «&nbsp;plate&nbsp;» (en anglais *flat*, d'où le `f` dans le nom de la fonction) dans le cas d'un croisement de 3 variables ou plus, plutôt que sous la forme d'un array comme le fait la fonction `table`. Elle accepte les mêmes types d'entrées que `table` (série d'objets atomiques à une dimension ou objet récursif dont les éléments sont interprétables en facteurs) et peut aussi recevoir une sortie de la fonction `table`, comme dans l'exemple suivant.

```{r}
ftable(t3)
```


\vspace{6pt}
<p style="font-size:110%">
**Fonctions `xtabs`**
</p>

La [fonction `xtabs`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/xtabs.html) fait le même calcul que les fonctions précédentes, mais elle prend en entrée une formule. Le tableau de fréquences à deux variables créé précédemment peut être réobtenu de la façon suivante avec `xtabs`.

```{r}
xtabs(~ yeux + cheveux, data = sondage)
```

La fonction `xtabs` est utile lorsque les données que nous avons en main contiennent déjà des fréquences, car il est possible d'inclure une variable réponse contenant des dénombrements dans la formule que nous lui fournissons en entrée. Par exemple, `xtabs` permet de facilement retrouver le tableau de fréquences marginales croisées entre les variables `yeux` et `cheveux` à partir du tableau de fréquences à trois variables produit précédemment mis sous forme de data frame, qui a l'allure suivante.

```{r}
t3_df <- as.data.frame(t3)
t3_df
```

Il suffit de procéder comme suit&nbsp;:

```{r}
t2 <- xtabs(Freq ~ yeux + cheveux, data = t3_df)
t2
```


\vspace{6pt}
<p style="font-size:110%">
**Autres fonctions relatives au calcul de fréquences**
</p>

Les fonctions [`marginSums`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/marginSums.html), [`addmargins`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/addmargins.html) et [`proportions`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/proportions.html) permettent de calculer des fréquences marginales ou relatives à partir d'un tableau de fréquences. Voici quelques exemples d'utilisation de ces fonctions exploitant le tableau de fréquences à deux variables produit ci-dessus.

```{r}
# Fréquences marginales en colonnes&nbsp;:
marginSums(t2, margin = 2)

# Fréquences marginales ajoutées au tableau&nbsp;:
addmargins(t2)

# Fréquences relatives croisées&nbsp;:
proportions(t2)

# Fréquences relatives conditionnelles à la variable yeux&nbsp;:
proportions(t2, margin = 1)
```


\vspace{6pt}
<p style="font-size:110%">
**Transformation du format d'un objet de classe `"table"`**
</p>

Les fonctions `table` et `xtabs` attribuent à l'objet qu'ils retournent en sortie la classe `"table"`, comme nous pouvons le constater en observant l'objet `t2`. 

```{r}
attributes(t2)
str(t2)
```

Il est parfois utile de transformer un objet de classe `"table"` en un array (matrice si la table croise deux variables) ou un data frame. Pour la transformation en array, il suffit de retirer l'attribut `class` avec la [fonction `unclass`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html), comme dans cet exemple&nbsp;:

```{r}
str(unclass(t2))
```

Comme nous avons pu le constater dans un exemple précédent, la transformation en data frame crée pour sa part un jeu de données contenant une ligne par combinaison distincte des niveaux des facteurs croisés dans la table. Le data frame obtenu comporte une colonne par facteur, ainsi qu'une colonne nommée `Freq` contenant les fréquences dans la table. En voici un exemple&nbsp;:

```{r}
str(as.data.frame(t2))
```

## Énumération de combinaisons

Un fonction utile pour énumérer toutes les combinaisons des niveaux d'un facteur est [`expand.grid`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/expand.grid.html). Par exemple, retrouvons avec cette fonction toutes les combinaisons présentes dans le data frame `t3_df` créé précédemment.

```{r}
expand.grid(
  yeux = c("bleu", "brun", "vert"),
  cheveux = c("blond", "brun", "noir"),
  genre = c("féminin", "masculin")
)
```

Il faut fournir en entrée à `expand.grid` les valeurs à combiner. Si les vecteurs ou facteurs contenant ces valeurs sont fournis avec des noms, comme dans l'exemple précédent (via les assignations), les colonnes du data frame retourné en sortie par `expand.grid` porteront ces noms.

Une autre fonction R permet d'énumérer des combinaisons possibles&nbsp;: la [fonction `combn`](https://stat.ethz.ch/R-manual/R-patched/library/utils/html/combn.html). Il s'agit de combinaisons au sens mathématique cette fois, donc «&nbsp;de dispositions non ordonnées d'un certain nombre d'éléments d'un ensemble&nbsp;» (définition tirée du [site web alloprof](https://www.alloprof.qc.ca/fr/eleves/bv/mathematiques/les-permutations-les-arrangements-et-les-combinai-m1346)). Par exemple, voici toutes les combinaisons possibles de 3 éléments parmi l'ensemble `c("Ève", "Jean", "Mia", "Paul")`, trouvées par la fonction `combn`.

```{r}
combn(x = c("Ève", "Jean", "Mia", "Paul"), m = 3)
```

Contrairement à `expand.grid` qui présente les combinaisons possibles ligne par ligne, chaque colonne de la sortie produite par `combn` représente une combinaison possible.


Notons finalement que la [fonction `choose`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Special.html) mentionnée précédemment permet de compter le nombre de combinaisons possibles de `k` éléments d'un ensemble de taille `n`. Elle calcule donc le [coefficient binomial](https://fr.wikipedia.org/wiki/Coefficient_binomial) ${n\choose k}$. 

```{r}
# Nombre de combinaisons possibles dans l'exemple précédent&nbsp;:
choose(n = 4, k = 3)
```

***

# Distributions de probabilité

Le package `stats` de l'installation de base de R comprend, pour plusieurs distributions de probabilité, des fonctions de calcul de&nbsp;:

- la fonction de densité (forme `d*` où `*` change selon la distribution), 
- la fonction de répartition (forme `p*`) et 
- la fonction quantile (forme `q*`).

La [fiche d'aide ouverte par la commande `help(Distributions)`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/Distributions.html) énumère toutes les distributions de probabilité offertes dans le package `stats`. Il existe aussi des fonctions relatives à d'autres distributions de probabilité dans des packages sur le CRAN (voir https://CRAN.R-project.org/view=Distributions pour découvrir ce qui est offert).

Ces fonctions sont utiles notamment pour calculer des valeurs critiques ou des seuils observés de tests d'hypothèses. Un exemple est présenté plus loin.


## Fonction de densité

Les fonctions R implémentant des [fonctions de densité](https://fr.wikipedia.org/wiki/Densit%C3%A9_de_probabilit%C3%A9) ont un nom qui débute par le lettre `d` pour *density*. Leur premier argument est toujours un vecteur de valeurs en lesquelles calculer la fonction de densité. Les arguments suivants servent à spécifier les valeurs des paramètres de la distribution.

Dans le cas d'une variable aléatoire discrète, la fonction de densité est plus justement appelée [fonction de masse](https://fr.wikipedia.org/wiki/Fonction_de_masse_(probabilit%C3%A9s)). Il s'agit alors d'une probabilité, pour une variable aléatoire suivant une certaine distribution, de prendre une certaine valeur.


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: distribution binomiale**
</p>

Soit $X$ une variable aléatoire représentant le nombre de 6 obtenus lors de 5 lancés d'un dé. Cette variable aléatoire suit une [distribution binomiale](https://fr.wikipedia.org/wiki/Loi_binomiale) de paramètres $n = 5$ et $p = 1/6$, donc $X \sim Bin(n = 5, p = 1/6)$.

Calculons $P(X = 2)$, soit la probabilité que la variable aléatoire $X$ prenne la valeur 2.

```{r}
dbinom(x = 2, size = 5, prob = 1/6)
```

La fonction `dbinom` implémente donc la fonction de masse d'une distribution binomiale. Les arguments `size` et `prob` sont les paramètres $n$ et $p$ de la distribution, selon la notation utilisée ci-dessus.

Les fonctions de la famille `d*` peuvent calculer plusieurs valeurs de densité par un seul appel de la fonction, car celles-ci acceptent des valeurs d'arguments de longueur supérieure à 1. Ces fonctions travaillent donc de façon vectorielle, comme presque toutes les fonctions de calcul en R.

Voici un exemple de code R permettant de représenter graphiquement la densité $Bin(n = 5, p = 1/6)$ complète, en mettant en évidence la valeur calculée ci-dessus, soit $P(X = 2)$. *(Nous verrons dans les [notes sur les graphiques](https://stt4230.rbind.io/communication_resultats/graphiques_r/) comment produire ce genre de figure et les suivantes.)*

```{r out.width = "70%"}
barplot(
  height = dbinom(0:5, size = 5, prob = 1/6), 
  names.arg = 0:5,
  main = "Densité Binomiale(5,1/6)",
  xlab = "x",
  ylab = "dbinom(x, size = 5, prob = 1/6)"
)
barplot(
  height = c(0, 0, dbinom(2, size = 5, prob = 1/6), 0, 0, 0),
  col = "blue",
  add = TRUE
)
```


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: distribution normale standard**
</p>

Supposons maintenant que $X$ est une variable aléatoire continue de [distribution normale](https://fr.wikipedia.org/wiki/Loi_normale) standard, donc $X \sim N(\mu = 0, \sigma^2 = 1)$. La valeur de la fonction de densité pour cette distribution en la valeur $x = 1$, souvent notée $f_X(1)$, vaut&nbsp;:

```{r}
dnorm(x = 1)
```

Voici une représentation graphique de la densité complète dans laquelle la valeur calculée ci-dessus est mise en évidence.

```{r out.width = "50%", fig.width = 5}
curve(expr = dnorm, xlim = c(-3, 3), main = "Densité N(0,1)")
segments(
  x0 = c(-4, 1), y0 = dnorm(1), x1 = 1, y1 = c(dnorm(1), -1), 
  lty = 2, col = "blue"
)
```

Ici, nous n'avons pas eu besoin de fournir des valeurs aux arguments de la fonction `dnorm` relatifs aux paramètres de la distribution, parce que nous avons utilisés leurs valeurs par défaut. Ces paramètres, pour la densité $N(\mu, \sigma^2)$, sont représentés par les arguments `mean` = $\mu$ et `sd` = $\sigma$ (remarquez que l'argument de la fonction R représente l'écart-type, pas la variance).

Tout comme le premier argument, nommé $x$, les arguments des fonctions de la famille `d*` représentant des paramètres de la distribution acceptent aussi en entrée plus d'une valeur. Voici un exemple, qui permet de calculer la densité en $x = 1$ pour $X \sim N(\mu = -2, \sigma^2 = 1)$, $X \sim N(\mu = 0, \sigma^2 = 2.25)$ et $X \sim N(\mu = 1, \sigma^2 = 4)$ en un seul appel à la fonction `dnorm`.

```{r}
dnorm(x = 1, mean = c(-2, 0, 1), sd = c(1, 1.5, 2))
```

## Fonction de répartition

La [fonction de répartition](https://fr.wikipedia.org/wiki/Fonction_de_r%C3%A9partition) d'une variable aléatoire $X$ est définie par $F_X(x) = P(X \le x)$. Il s'agit donc toujours d'une probabilité, d'où le `p` au début des noms des fonctions R implémentant des fonctions de répartition.


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: distribution normale standard**
</p>

Prenons encore comme exemple la distribution normale standard. Nous avons donc $X \sim N(0, 1)$. Calculons la valeur de la fonction de répartition de cette variable aléatoire en $x = 1$.

```{r}
pnorm(q = 1)
```

Il s'agit de la valeur de la probabilité $P(X \le 1)$.

Le premier argument des fonctions de la famille `p*` ne se nomme pas `x`, il se nomme plutôt `q`. Cette lettre réfère au mot quantile et souligne le lien entre les fonctions de répartition et les fonctions quantiles. Les arguments suivants des fonctions de la famille `p*` permettent de spécifier les valeurs des paramètres de la distribution, comme pour les fonctions de la famille `p*`.

Voici une illustration graphique du lien entre la fonction de densité et la fonction de répartition en utilisant la distribution normale standard. La valeur de la fonction de répartition en un point quelconque $x$ (dans le graphique $x = 1$) est égale à l'aire sous la courbe de densité entre $-\infty$ et $x$. 

```{r out.width = "100%", fig.width = 10}
par.default <- par(mfrow = c(1, 2))

curve(expr = dnorm, xlim = c(-3, 3), main = "Densité N(0,1)")
x <- seq(from = -3, to = 1, length = 100)
polygon(x = c(x, 1, -3), y = c(dnorm(x), 0, 0), col = "blue")

curve(
  expr = pnorm, xlim = c(-3, 3), 
  main = "Fonction de répartition N(0,1)", xname = "q"
)
segments(
  x0 = c(-4, 1), y0 = pnorm(1), x1 = 1, y1 = c(pnorm(1), -1), 
  lty = 2, col = "blue"
)

par(par.default)
```


## Fonction quantile

La [fonction quantile](https://fr.wikipedia.org/wiki/Fonction_quantile) est l'inverse généralisé de la fonction de répartition. Les fonctions R implémentant des fonctions quantile ont un nom qui débute par le lettre `q` pour *quantile*.


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: distribution normale standard**
</p>

Pour clore l'exemple de la distribution normale standard, voyons de quoi à l'air la fonction quantile de cette distribution.

Premièrement, calculons la valeur de la fonction quantile en un point, disons en $p = 0.8413447$.

```{r}
qnorm(p = 0.8413447)
```

Il s'agit de la valeur $x$ pour laquelle $P(X \le x) = 0.8413447$, où $X \sim N(0, 1)$.

Le premier argument d'une fonction de la famille `q*` se nomme `p`. Cette notation peut nous aider à nous rappeler que cet argument représente une probabilité et accepte donc seulement des valeurs entre 0 et 1. Encore une fois, les arguments suivants des fonctions de la famille `q*` permettent de spécifier les valeurs des paramètres de la distribution.

Le graphique suivant illustre le lien entre la fonction de répartition et la fonction quantile. Le graphique de la fonction quantile est simplement obtenu en inversant les axes du graphique de la fonction de répartition.

```{r out.width = "100%", fig.width = 10}
par.default <- par(mfrow = c(1,2), pty = "s")

curve(
  expr = pnorm, xlim = c(-3, 3), n = 1000, ylim = c(0, 1), asp = 6,
  main = "Fonction de répartition N(0,1)", xname = "q"
)
segments(
  x0 = c(-4, 1), y0 = pnorm(1),  x1 = 1, y1 = c(pnorm(1), -1), 
  lty = 2, col = "blue"
)

curve(
  expr = qnorm, xlim = c(0, 1), n = 1000, ylim = c(-3, 3), asp = 1/6, 
  main = "Fonction quantile  N(0,1)", xname = "p"
)
segments(
  x0 = c(-0.2, pnorm(1)), y0 = qnorm(pnorm(1)), 
  x1 = pnorm(1), y1 = c(qnorm(pnorm(1)), -4), 
  lty = 2, col = "blue"
)

par(par.default)
```


***

# Génération de nombres pseudo-aléatoires

En R, les fonctions `r*` permettent de générer pseudo-aléatoirement des observations selon une certaine distribution désignée par `*`. La lettre `r` au début de leur nom signifie *random*.

Par exemple, voici la représentation graphique de 3 échantillons générés aléatoirement selon 3 distributions différentes&nbsp;: des distributions normale, uniforme continue et khi-deux. Pour chaque échantillon, nous traçons l'histogramme des observations simulées pour représenter leur densité empirique. Nous superposons à cet histogramme la courbe de densité de la distribution théorique à partir de laquelle les observations ont été générées.


```{r, eval = FALSE}
par.default <- par(mfrow = c(1, 3))

# Densité normale d'espérance 5 et de variance 4
x1 <- rnorm(1000, mean = 5, sd = 2)
hist(x = x1, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x1")
curve(expr = dnorm(x, mean = 5, sd = 2), add = TRUE, col = "blue")
title(main = "courbe bleue = densité visée N(5,4)", line = 0.5)

# Densité uniforme continue entre 2 et 8
x2 <- runif(1000, min = 2, max = 8)
hist(x = x2, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x2")
curve(expr = dunif(x, min = 2, max = 8), add = TRUE, col = "blue")
title(main = "courbe bleue = densité visée U(2,8)", line = 0.5)

# Densité chi-carré à 4 degrés de liberté
x3 <- rchisq(1000, df = 4)
hist(x = x3, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x3")
curve(expr = dchisq(x, df = 4), add = TRUE, col = "blue")
title(main = expression(paste("courbe bleue = densité visée ", chi[4]^2)), line = 0.5)

par(par.default)
```

```{r, echo = FALSE, fig.width = 10, fig.height = 5}
par.default <- par(mfrow = c(1,3))

set.seed(150)
x1 <- rnorm(1000, mean = 5, sd = 2)
hist(x1, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x1")
title(main = "courbe bleue = densité visée N(5,4)", line = 0.5, cex.main = 1, font.main = 1)
curve(dnorm(x, mean = 5, sd = 2), add = TRUE, col = "blue")

set.seed(264)
x2 <- runif(1000, min = 2, max = 8)
hist(x2, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x2")
title(main = "courbe bleue = densité visée U(2,8)", line = 0.5, cex.main = 1, font.main = 1)
curve(dunif(x, min = 2, max = 8), add = TRUE, col = "blue")

set.seed(321)
x3 <- rchisq(1000, df = 4)
hist(x3, freq = FALSE, ylab = "Proportion", main = "Densité empirique de x3")
title(main = expression(paste("courbe bleue = densité visée ", chi[4]^2)), line = 0.5, cex.main = 1, font.main = 1)
curve(dchisq(x, df = 4), add = TRUE, col = "blue")

set.seed(NULL)
par(par.default)
```

Comme nous pouvons le constater sur ces graphiques, la distribution empirique des observations générées avec ces fonctions se rapproche vraiment de la distribution théorique demandée. En générant un nombre encore plus grand d'observations (ici nous en avons généré 1000 pour chaque distribution), la densité empirique se rapprocherait encore plus de la densité théorique.


## Fonction `sample`

La fonction [`sample`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html) permet de tirer un échantillon aléatoire parmi un ensemble d'éléments fourni à son argument `x` sous forme de vecteur.

```{r}
sample(x = c("Luc", "Kim", "Paul", "Ève"))
```

Ce vecteur peut contenir des données de n'importe quel type.

```{r}
sample(x = 1:6)
```

Par défaut, `sample` effectue un tirage sans remise et sélectionne autant d'éléments que l'ensemble de départ en contient. La fonction effectue donc une permutation aléatoire des éléments de l'ensemble de départ. L'argument `size` permet cependant de contrôler la taille de l'échantillon tiré.

```{r}
sample(x = 1:6, size = 5)
```

L'argument `replace` permet quant à lui de spécifier si le tirage doit être effectué avec (`replace = TRUE`) ou sans remise (`replace = FALSE`, valeur par défaut).

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

Il est aussi possible d'attribuer des probabilité de sélection à chacun des éléments grâce à l'argument `prob`. Par défaut, tous les éléments ont une probabilité égale d'être tiré. 

```{r}
sample(x = 1:6, size = 20, replace = TRUE, prob = c(1/2, rep(1/10, times = 5)))
```

La fonction [`sample.int`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html) est très similaire à la fonction `sample`, mais elle prend comme premier argument un seul entier, `n`, et tire aléatoirement `size` entiers entre 1 et `n`.

```{r}
sample.int(n = 6, size = 4)
```

Si nous souhaitons sélectionner aléatoirement des observations (lignes) dans un jeu de données, il est d'usage de sélectionner d'abord des entiers compris entre 1 et le nombre total d'observations, puis d'extraire du jeu de donnée les observations sur les lignes portant les numéros sélectionnés. Voici un exemple, utilisant [célèbres données iris](https://fr.wikipedia.org/wiki/Iris_de_Fisher), incluses dans l'installation de base de R dans le data frame nommé [`iris`](https://stat.ethz.ch/R-manual/R-patched/library/datasets/html/iris.html) (du package `datasets`).

```{r}
str(iris)
index_ech <- sample.int(n = nrow(iris), size = 5, replace = FALSE)
index_ech
iris_ech <- iris[index_ech, ]
iris_ech
```

## Germe de la génération pseudo-aléatoire

Les nombres générés avec les fonctions `r*` et les échantillons tirés avec `sample` sont qualifiés de pseudo-aléatoires, car ils proviennent d'un algorithme déterministe qui tente de reproduire le hasard. Un tel algorithme est nommé en anglais *random number generator* (RNG) ou *pseudo-random number generator*. La fiche d'aide ouverte par la commande [`help(Random)`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Random.html) contient de l'information sur la génération de nombres pseudo-aléatoires en R.

Plusieurs RNG sont implémentés en R. Celui utilisé par défaut, nommé Mersenne Twister, a été choisi parce qu'il est réputé être bon. Sans entrer dans les détails du fonctionnement des RNG implémentés dans le package `base` de R, il faut savoir qu'ils travaillent tous à partir d'une séquence de nombres appelée *germe* (en anglais *seed*). En contrôlant ce germe, il est possible de générer de nouveau, autant de fois que désiré, les mêmes valeurs.

Par défaut, R contrôle le germe des RNG de façon automatique. Chaque fois qu'une commande faisant intervenir un RNG est évaluée, R crée un nouveau germe à partir, notamment, de l'heure à laquelle la commande est soumise. Ainsi, deux générations pseudo-aléatoires consécutives ne produisent en général pas le même résultat.
```{r}
sample(x = letters, size = 5)
sample(x = letters, size = 5)
```

En tout temps, il est possible de connaître le germe du RNG en R. Il est stocké dans un objet nommé `.Random.seed`. Cet objet est un vecteur numérique de longueur `r length(.Random.seed)` pour le RNG Mersenne Twister. Voyons de quoi ont l'air les premiers éléments de ce vecteur à différents moments.

```{r echo = TRUE, eval = FALSE}
str(.Random.seed)
```
```{r echo = FALSE, results = 'markup', R.options = list(width = 100)}
str(.Random.seed, width = 87, strict.width = 'cut')
```

```{r}
sample(x = letters, size = 5)
```

```{r echo = TRUE, eval = FALSE}
str(.Random.seed)
```
```{r echo = FALSE, results = 'markup', R.options = list(width = 100)}
str(.Random.seed, width = 87, strict.width = 'cut')
```

```{r}
sample(x = letters, size = 5)
```

```{r echo = TRUE, eval = FALSE}
str(.Random.seed)
```
```{r echo = FALSE, results = 'markup', R.options = list(width = 100)}
str(.Random.seed, width = 87, strict.width = 'cut')
```

Nous constatons qu'au moins un élément de ce vecteur (le deuxième élément) change à chaque fois que nous appelons la fonction `sample`. La fonction [`set.seed`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Random.html) permet de fixer le germe du RNG à partir d'une seule valeur entière. Par exemple, la commande suivante&nbsp;:

```{r}
set.seed(753)
```

spécifie le germe suivant&nbsp;:

```{r echo = TRUE, eval = FALSE}
str(.Random.seed)
```
```{r echo = FALSE, results = 'markup', R.options = list(width = 100)}
str(.Random.seed, width = 87, strict.width = 'cut')
```

En soumettant de nouveau le même appel à la fonction `sample`, nous obtenons l'échantillon suivant.

```{r}
sample(x = letters, size = 5)
```

La soumission de cette commande a eu pour effet de modifier le germe.

```{r echo = TRUE, eval = FALSE}
str(.Random.seed)
```
```{r echo = FALSE, results = 'markup', R.options = list(width = 100)}
str(.Random.seed, width = 87, strict.width = 'cut')
```

Donc si nous resoumettons la commande `sample`, nous n'obtiendrons sûrement pas le même résultat.

```{r}
sample(x = letters, size = 5)
```

Par contre, si nous fixons de nouveau le germe à partir de l'entier 753 avec `set.seed`, nous arrivons à obtenir de nouveau l'avant-dernier échantillon généré.


```{r}
set.seed(753)
sample(x = letters, size = 5)
```

À n'importe quel moment, dans n'importe qu'elle session R, nous obtenons l'échantillon {`r set.seed(753); sample(letters, size = 5)`} si nous soumettons la commande `set.seed(753)` avant la commande `sample(letters, size = 5)`.

L'utilité de fixer le germe d'une génération pseudo-aléatoire est de rendre son résultat reproductible. 

***

# Tests statistiques

Il existe des fonctions R pour faire des tests statistiques de base. En voici quelques-unes&nbsp;:

- tests sur une ou des moyennes&nbsp;: [`t.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/t.test.html);
- tests sur une ou des proportions&nbsp;: [`prop.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/prop.test.html), [`binom.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/binom.test.html);
- tests de comparaison de variances&nbsp;: [`var.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/var.test.html), [`bartlett.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/bartlett.test.html);
- tests sur une corrélation&nbsp;: [`cor.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.test.html);
- tests pour une distribution&nbsp;: [`shapiro.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/shapiro.test.html), [`ks.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ks.test.html);
- tests non paramétriques&nbsp;: [`wilcox.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/wilcox.test.html), [`kruskal.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/kruskal.test.html), [`friedman.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/friedman.test.html);
- tests sur des fréquences&nbsp;: [méthode `summary` pour un objet de classe `table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html) (produit par la fonction `table` ou `xtabs`), [`chisq.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/chisq.test.html), [`fisher.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/fisher.test.html), [`mantelhaen.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/mantelhaen.test.html).

Utilisons encore une fois les données `iris` pour construire un exemple de test de comparaison de moyennes. Nous allons comparer les largeurs moyennes des sépales des espèces *versicolor* et *virginica*.


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: test t bilatéral de comparaison de moyennes, avec variances inégales**
</p>

```{r}
t.test(
  formula = Sepal.Width ~ Species,
  data = iris,
  subset = Species %in% c("versicolor", "virginica")
)
```

Lorsque nous connaissons la valeur d'une statistique de test ainsi que sa loi sous l'hypothèse nulle, il est possible de calculer en R le seuil observé du test avec la bonne fonction `p*`. Par exemple, dans le test t ci-dessus, nous pouvons retrouver la valeur du seuil observé ainsi&nbsp;:
```{r}
# multiplication par 2, car le test est bilatéral et la loi t est symétrique
pt(q = -3.2058, df = 97.927)*2 
```


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: test non paramétrique équivalent**
</p>

```{r}
wilcox.test(
  formula = Sepal.Width ~ Species,
  data = iris, 
  subset = Species %in% c("versicolor", "virginica"), 
  exact = FALSE
)
```

***

# Ajustement de modèles

Il existe plusieurs fonctions en R pour ajuster des modèles. Les modèles les plus usuels sont&nbsp;:

- modèles linéaires, dont la régression&nbsp;: [`lm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html) pour *linear model*;
- modèle d'analyse de la variance&nbsp;: [`lm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html) ou [`aov`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/aov.html);
- modèles linéaires généralisés&nbsp;: [`glm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/glm.html);
- modèles linéaires mixtes (peuvent contenir des effets aléatoires)&nbsp;: `lmer` du package [`lme4`]( https://CRAN.R-project.org/package=lme4) ou `lme` du package [`nlme`](https://CRAN.R-project.org/package=nlme );
- modèles non linéaires&nbsp;: [`nls`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/nls.html).

À titre d'exemples, ajustons deux modèles sur les données iris.

\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: régression linéaire simple entre la largeur et la longueur des sépales**
</p>

```{r}
reg <- lm(formula = Sepal.Width ~ Sepal.Length, data = iris)
reg
```


\vspace{6pt}
<p style="font-size:110%">
**Exemple&nbsp;: ANOVA pour comparer les largeurs de sépales moyennes entre toutes les espèces**
</p>

```{r}
ANOVA <- aov(formula = Sepal.Width ~ Species, data = iris)
ANOVA
```


## Formules

Ces fonctions d'ajustement de modèles prennent obligatoirement en entrée une formule R assignée à l'[argument `formula`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/formula.html), tout comme la fonction `xtabs`. D'autres fonctions acceptent aussi en entrée une formule, sans que ce type d'argument soit obligatoire. C'est le cas des fonctions `aggregate`, `ftable`, plusieurs des fonctions effectuant un test (p. ex. `t.test`, `wilcox.test`) et certaines fonctions graphiques (p. ex. `plot`, `boxplot`).

Les fonctions prenant une formule en entrée ont toujours un argument `data` pour spécifier d'où tirer les variables incluses dans la formule. 

Une formule s'écrit sous la forme `y ~ x1 + x2` où `y` représente la variable réponse (ou à expliquer, ou dépendante, ou endogène) et `x1` et `x2` des variables explicatives (ou indépendantes, ou exogènes). Dans la partie de droite, les opérateurs suivants peuvent apparaître&nbsp;:

- «&nbsp;`+`&nbsp;»&nbsp;: pour ajouter des termes;
- «&nbsp;`-`&nbsp;»&nbsp;: pour soustraire des termes;
- «&nbsp;`0`&nbsp;»&nbsp;: ou `1` pour représenter l'ordonnée à l'origine (par défaut tout modèle linéaire comporte une ordonnée à l'origine, pour la retirer il faut ajouter `- 1` ou `+ 0` à la partie de droite de la formule);
- «&nbsp;`.`&nbsp;»&nbsp;: pour représenter toutes les variables dans le jeu de données fournit en argument `data`, autres que la variable mise à la gauche du `~` (note&nbsp;: le point signifie autre chose dans la fonction `update`).

Opérateurs propres aux facteurs&nbsp;:

- «&nbsp;`:`&nbsp;»&nbsp;: pour les termes d'interaction entre facteurs;
- «&nbsp;`*`&nbsp;»&nbsp;: pour le croisement de facteurs (`x1*x2` est équivalent à `x1 + x2 + x1:x2`);
- «&nbsp;`^`&nbsp;»&nbsp;: pour le croisement de facteurs jusqu'à un certain niveau d'interaction (par exemple `(x1 + x2 + x3)^2` va inclure tous les termes de croisement des facteurs jusqu'aux interactions doubles `x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3`, mais pas l'interaction triple `x1:x2:x3`);
- «&nbsp;`%in%`&nbsp;»&nbsp;: pour les facteurs emboîtés (dans `x2 %in% x1`,  `x2` est emboîté dans `x1`).

Autre opérateur&nbsp;:

- «&nbsp;`|`&nbsp;»&nbsp;: (p. ex. `y ~ x1 | x2`) n'a pas toujours exactement la même signification selon la fonction, il représente parfois&nbsp;:
    + un conditionnement par rapport à une variable (p. ex. fonction [`coplot`](https://stat.ethz.ch/R-manual/R-patched/library/graphics/html/coplot.html)),
    + la structure d'effets aléatoires (p. ex. fonctions `lmer` du package [`lme4`]( https://CRAN.R-project.org/package=lme4) ou `lme` du package [`nlme`](https://CRAN.R-project.org/package=nlme )).


Les formules peuvent inclurent des appels à des fonctions pour transformer les variables. Par exemple, pour ajuster un modèle sur la racine carrée de la variable réponse, nous pouvons écrire `sqrt(y) ~ x1 + x2`. Certaines transformations pourraient faire intervenir un ou des opérateurs ayant une signification modifiée dans une formule. Par exemple, imaginons que nous voulons ajuster un modèle avec une seule variable explicative créée en additionnant les valeurs des variables `x1` et `x2`. La formule `y ~ x1 + x2` n'ajuste pas ce modèle puisque, dans une formule, l'opérateur `+` signifie «&nbsp;ajouter des termes&nbsp;» et non plus «&nbsp;additionner des valeurs&nbsp;». Alors est-il possible d'ajuster le modèle souhaité (*sans ajouter une nouvelle variable dans les données*)?

Oui, c'est possible grâce à la fonction `I`. Il faut encadrer l'opération arithmétique à effectuer dans la formule d'un appel à la fonction `I`. Par exemple, `y ~ I(x1 + x2)` ajuste un modèle à une seule variable explicative formée de la somme des valeurs de `x1` et `x2`. Ainsi, `I()` permet d'utiliser la signification usuelle des opérateurs et non celle spécifique aux formules.

### Exemples

Voici quelques exemples, dans lesquels nous omettrons de nommer le premier argument, soit `formula`, pour alléger la présentation et parce qu'il est usuel de ne pas nommer ce premier argument.

#### Retrait de l'ordonnée à l'origine

\mbox{}

```{r, R.options= list(width = 100)}
reg <- lm(Sepal.Width ~ Sepal.Length - 1, data = iris)
# ou encore&nbsp;:
reg <- lm(Sepal.Width ~ Sepal.Length + 0, data = iris)
```
```{r, R.options= list(width = 100)}
coef(summary(reg))
```

#### Régression log-log

\mbox{}

```{r, R.options= list(width = 100)}
reg <- lm(log(Sepal.Width) ~ log(Sepal.Length), data = iris)
```
```{r, R.options= list(width = 100)}
coef(summary(reg))
```

#### Régression polynomiale

\mbox{}

```{r, R.options= list(width = 100)}
reg <- lm(Sepal.Width ~ Sepal.Length + Sepal.Length^2, data = iris)
```
```{r, R.options= list(width = 100)}
coef(summary(reg))
```
Non, ça n'a pas fonctionné. Dans une formule, l'opérateur `^` ne signifie pas exposant. Pour demander à R d'utiliser la signification usuelle de l'opérateur, et non celle spécifique aux formules, il faut encadrer le terme contenant l'opérateur de `I()` comme suit&nbsp;:
```{r, R.options= list(width = 100)}
reg <- lm(Sepal.Width ~ Sepal.Length + I(Sepal.Length^2), data = iris)
```
```{r, R.options= list(width = 100)}
coef(summary(reg))
```

&nbsp;

**Création de variables catégoriques pour les exemples à venir** *(nous verrons dans les [notes sur le prétraitement de données comment utiliser la fonction `cut`](https://stt4230.rbind.io/manipulation_donnees/pretraitement_donnees_r/))*&nbsp;:
```{r, R.options= list(width = 100)}
iris$Sepal.Length_catego <- cut(
  x = iris$Sepal.Length, 
  breaks = c(-Inf, quantile(iris$Sepal.Length, probs = c(1/3, 2/3)), Inf),
  right = FALSE
)
iris$Petal.Width_catego <- cut(
  x = iris$Petal.Width, 
  breaks = c(-Inf, quantile(iris$Petal.Width, probs = c(1/3, 2/3)), Inf), 
  right = FALSE
  )
```

#### Anova à 3 facteurs, modèle complet

\mbox{}

```{r, R.options= list(width = 100)}
ANOVA <- aov(Sepal.Width ~ Species*Sepal.Length_catego*Petal.Width_catego, data = iris)
# ou encore
ANOVA <- aov(
  Sepal.Width ~ (Species + Sepal.Length_catego + Petal.Width_catego)^3,
  data = iris
)
```

```{r, R.options= list(width = 100)}
summary(ANOVA)
```

#### Anova à 3 facteurs, modèle complet sans l'interaction triple

\mbox{}

```{r, R.options= list(width = 100)}
ANOVA <- aov(
  Sepal.Width ~ Species*Sepal.Length_catego*Petal.Width_catego - 
                Species:Sepal.Length_catego:Petal.Width_catego, 
  data = iris
)
# ou encore
ANOVA <- aov(
  Sepal.Width ~ (Species + Sepal.Length_catego + Petal.Width_catego)^2, 
  data = iris
)
```
```{r, R.options= list(width = 100)}
summary(ANOVA)
```


### Arguments accompagnant les formules

Pour les fonctions prenant une formule comme premier argument, cet argument est souvent le seul argument obligatoire.

```{r}
reg <- lm(iris$Sepal.Width ~ iris$Sepal.Length)
coef(summary(reg))
```

Cependant, un argument `formula` est toujours accompagné d'un argument `data`. Typiquement, l'utilisateur fournit à `data` un data frame contenant en colonnes les variables à inclure dans la formule. Utiliser l'argument `data` permet d'alléger la formule. Les noms de variables dans la formule sont d'abord recherchés parmi les noms des éléments de `data`.  

```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris)  # (plus de iris$ dans la formule)
coef(summary(reg))
```

&nbsp;

En plus de l'argument `data`, les fonctions prenant une formule en entrée ont la plupart du temps les arguments&nbsp;:

- `subset` pour spécifier un sous-ensemble de données à utiliser (par défaut toutes les observations de `data` sont utilisées) et 
- `na.action` pour spécifier quoi faire avec les valeurs manquantes (voir [`help(na.fail)`](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html)). 


#### Ajustement d'un modèle sur un sous-ensemble des données

\mbox{}

Un argument `subset` se spécifie comme l'argument `subset` de la fonction [`subset`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html). Sa valeur doit être un vecteur logique dont la longueur est égale au nombre d'observations dans le jeu de données fourni à l'argument `data`. Voici un exemple.

```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris, subset = Species == "setosa")
coef(summary(reg))
```

#### Modification du traitement des valeurs manquantes

\mbox{}

```{r}
iris_2 <- iris
iris_2$Sepal.Length[6] <- NA # pour insérer une donnée manquante (pas de NA dans iris)
```

La valeur fournie à l'argument `na.action` est le nom d'une fonction qui traite les données manquantes dans un jeu de données. Le comportement par défaut de l'argument `na.action` est régi par l'[option de session](https://stat.ethz.ch/R-manual/R-patched/library/base/html/options.html) du même nom.

```{r}
getOption("na.action")
```

Dans mon cas, `na.action` prend donc par défaut la valeur `na.omit`, ce qui a pour conséquence que les observations avec au moins une valeur de variable manquante sont omises (ligne complète non considérée).

Nous pourrions fournir à l'argument une autre des fonctions listées dans la fiche d'aide [`help(na.fail)`](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html). Par exemple, l'ajustement du modèle n'est pas effectué lorsque les données comportent des données manquantes si la valeur `na.fail` est fournie à `na.action`. 

```{r, eval = FALSE}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris_2, na.action = na.fail)
```
```
## Error in na.fail.default(list(Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9, &nbsp;: 
##   missing values in object
```

## Manipulation de la sortie

Lorsque nous affichons dans la console un objet produit en sortie d'une fonction d'ajustement de modèle, la sortie obtenue est brève.
```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris)
reg
```
En réalité, cet objet est une liste contenant plusieurs éléments.
```{r}
str(reg, list.len = 5)
```
L'objet obtenu de la fonction d'ajustement de modèle ne s'affiche pas comme une liste parce qu'un attribut classe lui est attribué et que la fonction polymorphe `print` possède une définition spécifique aux objets de cette classe.
```{r}
class(reg)
print(reg)
```
C'est une caractéristique orientée objet du langage R. Dans la terminologie de R, une fonction polymorphe est appelée *fonction générique* et les différentes définitions de cette fonction sont appelées *méthodes*. Les fonctions génériques, telles que les fonctions `print`, `plot` et `summary`, ont un comportement qui varie en fonction de la classe du premier argument qui leur est fourni en entrée.

Rappelons que taper le nom d'un objet dans la console est en fait un raccourci pour soumettre la fonction `print` avec l'objet à afficher en argument.

Si nous retirons l'attribut classe de l'objet, nous retombons sur un affichage usuel pour un objet de type liste.
```{r, eval = FALSE}
class(reg) <- NULL
reg # résultat non affiché, car trop long
```
L'attribut classe peut même contenir plus d'une classe.
```{r}
ANOVA <- aov(Sepal.Width ~ Species, data = iris)
class(ANOVA)
```
Souvent, le nom de la classe d'un objet est le nom de la fonction qui a produit cet objet. Les objets retournés par la fonction `aov` ont deux classes, car en réalité la fonction `aov` appelle la fonction `lm`. 

### Fonctions génériques d'extraction d'information

Voici la liste des fonctions génériques les plus couramment utilisées pour tirer de l'information d'un objet produit par une fonction d'ajustement de modèle&nbsp;:

- [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html)&nbsp;: pour afficher un résumé des informations plus long que ce qui est affiché avec `print` et pour produire des résultats supplémentaires;
- [`coef`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/coef.html) (ou son alias `coefficients`) et [`confint`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/confint.html)&nbsp;: pour afficher les coefficients et pour produire des intervalles de confiance pour les coefficients d'un modèle; 
- [`residuals`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/residuals.html) et [`fitted`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/fitted.values.html)&nbsp;: pour extraire les résidus et les valeurs prédites;
- [`predict`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.html)&nbsp;: pour effectuer des prédictions pour de nouvelles observations;
- [`anova`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/anova.html)&nbsp;: pour calculer la table d'analyse de la variance (ANOVA) du modèle;
- [`model.tables`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/model.tables.html) et [`TukeyHSD`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/TukeyHSD.html) (pour la classe `aov`)&nbsp;: pour calculer les moyennes par niveaux de facteurs et pour faire des comparaisons multiples de Tukey sur ces moyennes; 
- [`deviance`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/deviance.html), [`logLik`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/logLik.html), [`AIC`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/AIC.html), [`BIC`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/AIC.html)&nbsp;: pour extraire la déviance, la log-vraisemblance maximisée, le AIC et le BIC.

L'utilisation de ces fonctions est la façon usuelle en R d'extraire des résultats relatifs à un modèle. Par exemple, pour extraire les coefficients d'un modèle, nous pouvons utiliser&nbsp;:

```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris)
coef(reg)
```

Notons cependant qu'il est aussi possible d'extraire cette information en accédant directement aux éléments de `reg`, qui est une liste.

```{r}
reg$coefficients
```

&nbsp;

Voici quelques exemples d'utilisation des fonctions d'extraction d'information &nbsp;:
```{r}
reg <- lm(Sepal.Width ~ Sepal.Length + Petal.Width, data = iris)
summary(reg)
confint(reg)
str(residuals(reg))
predict(
  reg, 
  newdata = data.frame(
    Sepal.Length = c(5, 6),
    Petal.Width = c(1, 2)
  )
)
ANOVA <- aov(Sepal.Width ~ Species + Sepal.Length_catego, data = iris)
summary(ANOVA)
anova(ANOVA)
model.tables(ANOVA, type = "means")
TukeyHSD(ANOVA)
```

### Résultats additionnels fournis par `summary`

La fonction générique `summary` ne fait pas que produire un affichage du modèle ajusté plus complet que la fonction générique `print`. Elle produit des résultats supplémentaires concernant le modèle. Par exemple, pour un modèle produit avec `lm`, comparons ce que produit directement la fonction `lm` et ce que produit la fonction générique `summary` pour un objet retourné par `lm`.

```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris)
reg_summary <- summary(reg)
sort(names(reg))
sort(names(reg_summary))
```

Seulement `r length(intersect(names(reg), names(reg_summary)))` éléments de la liste `reg` portent des noms aussi présents dans la liste `reg_summary`. Et des éléments de même nom dans les deux listes ne contiennent pas toujours la même chose.

```{r}
reg$coefficients
reg_summary$coefficients
```

Les éléments produits par `summary` tendent à contenir plus de détails que les éléments obtenus directement de `lm`.

La fonction `summary` réalise donc des calculs supplémentaires relatifs au modèle. Par exemple, pour un modèle ajusté avec `lm`, elle réalise les tests sur les termes du modèle et calcule le coefficient de détermination (R^2^), soit une mesure souvent utilisée pour évaluer la qualité de la prédiction du modèle.

```{r}
reg_summary$r.squared
```

Pour un modèle d'analyse de la variance ajusté avec `aov`, la fonction `summary` produit la table d'ANOVA complète, tout comme la fonction `anova` le fait.

```{r}
ANOVA <- aov(Sepal.Width ~ Species + Sepal.Length_catego, data = iris)
ANOVA_summary <- summary(ANOVA)
str(ANOVA_summary)
```



### Mise en forme avec le package `broom`

Le [package `broom`](https://broom.tidymodels.org/) offre des fonctions pour faciliter la manipulation de sorties d'une fonction d'ajustement de modèle. Les trois principales fonctions de ce package sont les suivantes&nbsp;:

- `tidy`&nbsp;:  produit un résumé des principaux résultats statistiques d'un modèle, dans le cas d'un modèle linéaire il s'agit d'une table des tests sur les coefficients du modèle;
- `augment`&nbsp;: ajoute aux données sur lesquelles le modèle a été ajusté des informations tirées du modèle, comme des résidus et des valeurs prédites;
- `glance`&nbsp;: réunit dans un seul data frame à une ligne plusieurs statistiques globales au modèle, comme des statistiques d'ajustement du modèle.

Voici quelques exemples&nbsp;:

```{r}
reg <- lm(Sepal.Width ~ Sepal.Length, data = iris)
```

```{r R.options=list(width = 95)}
library(broom)
tidy(reg) # très similaire à coef(summary(reg)) pour une sortie de lm
head(augment(reg))
glance(reg)
```

Plus d'informations peuvent être trouvées dans la documentation du package&nbsp;: https://broom.tidymodels.org/


***

# Résumé


<p style="font-size:110%">
**Statistiques descriptives**
</p>

Calcul | opère de façon vectorielle | combine, retourne une valeur | combine, retourne valeur(s) | combine, retourne un vecteur|
-----------|-------|-------------|-----------|----------|
mesure de position | [`pmin`, `pmax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html) | [`min`, `max`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html), [`which.min`, `which.max`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html) | [`range`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html), [`quantile`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/quantile.html), [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html) | [`cummin`, `cummax`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html), [`rank`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html) 
tendance centrale | | [`mean`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/mean.html), [`median`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/median.html) | [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html) | |
dispersion | | [`sd`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/sd.html), [`IQR`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/IQR.html), [`mad`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/mad.html) | [`var`, `cov`, `cor`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html) | |
fréquences | | | [`table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html), [`ftable`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ftable.html), [`xtabs`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/xtabs.html), [`summary`]((https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html)) | |

- Traitement des données manquantes&nbsp;:
    + argument `na.rm`&nbsp;,
    + fonction [`na.omit`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html);
- calcul de fréquences marginales ou relatives à partir d'un tableau de fréquences&nbsp;:  
[`marginSums`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/marginSums.html), [`addmargins`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/addmargins.html), [`proportions`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/proportions.html).
- énumération de combinaisons&nbsp;: [`expand.grid`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/expand.grid.html), [`combn`](https://stat.ethz.ch/R-manual/R-patched/library/utils/html/combn.html).
  

\vspace{6pt}
<p style="font-size:110%">
**Distributions de probabilité et génération de nombres aléatoires**
</p>

Famille de fonction | Description
-----------------|---------------------------------------------------------------
`d*` | **fonction de densité** de la distribution `*`
`p*` | **fonction de répartition** de la distribution `*`
`q*` | **fonction quantile** de la distribution `*`
`r*` | génération pseudo-aléatoirement d'observations selon la distribution `*`

Liste de toutes les distributions `*` offertes en R de base&nbsp;: [`help(Distributions)`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/Distributions.html)

- fonction [`sample`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html) (ou [`sample.int`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html))&nbsp;: tirage aléatoire d'échantillons
- fonction [`set.seed`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/Random.html)&nbsp;: pour fixer le germe du tirage pseudo-aléatoire


\vspace{6pt}
<p style="font-size:110%">
**Tests statistiques**
</p>

Quelques fonctions R pour faire des tests statistiques de base&nbsp;:

- tests sur une ou des moyennes&nbsp;: [`t.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/t.test.html);
- tests sur une ou des proportions&nbsp;: [`prop.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/prop.test.html), [`binom.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/binom.test.html);
- tests de comparaison de variances&nbsp;: [`var.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/var.test.html), [`bartlett.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/bartlett.test.html);
- tests sur une corrélation&nbsp;: [`cor.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.test.html);
- tests pour une distribution&nbsp;: [`shapiro.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/shapiro.test.html), [`ks.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/ks.test.html);
- tests non paramétriques&nbsp;: [`wilcox.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/wilcox.test.html), [`kruskal.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/kruskal.test.html), [`friedman.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/friedman.test.html);
- tests sur des fréquences&nbsp;: [méthode `summary` pour un objet de classe `table`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/table.html) (produit par la fonction `table` ou `xtabs`), [`chisq.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/chisq.test.html), [`fisher.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/fisher.test.html), [`mantelhaen.test`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/mantelhaen.test.html).


\vspace{6pt}
<p style="font-size:110%">
**Ajustement de modèles**
</p>

Quelques fonctions R pour ajuster des modèles&nbsp;:

- modèles linéaires, dont la régression&nbsp;: [`lm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html);
- modèle d'analyse de la variance&nbsp;: [`lm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html) ou [`aov`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/aov.html);
- modèles linéaires généralisés&nbsp;: [`glm`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/glm.html);
- modèles linéaires mixtes (peuvent contenir des effets aléatoires)&nbsp;: `lmer` du package [`lme4`]( https://CRAN.R-project.org/package=lme4) ou `lme` du package [`nlme`](https://CRAN.R-project.org/package=nlme );
- modèles non linéaires&nbsp;: [`nls`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/nls.html).


\vspace{6pt}
<p style="font-size:110%">
**Formules R**
</p>

**Écriture générale**&nbsp;: `y ~ x1 + x2`  
où `y` = variable réponse, `x1` et `x2` = variables explicatives. 

**Opérateurs acceptés** et leur signification&nbsp;:

- `+` pour ajouter des termes;
- `-` pour soustraire des termes;
- `- 1` ou `+ 0` pour retirer l'ordonnée à l'origine;
- `.` pour représenter toutes les variables dans le jeu de données, autres que la variable mise à la gauche du `~` ;
- `:` pour les termes d'interaction entre facteurs;
- `*` pour le croisement de facteurs;
- `^` croisement de facteurs jusqu'à un certain niveau d'interaction;
- `%in%` pour les facteurs emboîtés;
- `|` pour un conditionnement ou spécifier des effets aléatoires

`I()` pour utiliser la signification usuelle des opérateurs et non celle spécifique aux formules.


\vspace{6pt}
<p style="font-size:110%">
**Sortie d'une fonction d'ajustement de modèle**
</p>

Affichage (`print`) vs liste contenant les objets retournés

La liste retournée a une ou des classes $\rightarrow$ programmation orientée objet

Fonctions pour tirer de l'information d'un objet produit par une fonction d'ajustement de modèle&nbsp;:

- [`summary`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html)&nbsp;: plus de résultats relatifs au modèle + affichage d'un résumé des informations;
- [`coef`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/coef.html) (ou son alias `coefficients`) et [`confint`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/confint.html)&nbsp;: coefficients et leurs intervalles de confiance; 
- [`residuals`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/residuals.html) et [`fitted`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/fitted.values.html)&nbsp;: résidus et valeurs prédites;
- [`predict`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.html)&nbsp;: prédiction pour une nouvelle observation;
- [`anova`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/anova.html)&nbsp;: table d'analyse de la variance du modèle;
- [`model.tables`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/model.tables.html) et [`TukeyHSD`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/TukeyHSD.html) (pour la classe `aov`)&nbsp;: moyennes par niveaux de facteurs et comparaisons multiples de Tukey; 
- [`deviance`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/deviance.html), [`logLik`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/logLik.html), [`AIC`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/AIC.html), [`BIC`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/AIC.html)&nbsp;: déviance, log-vraisemblance maximisée, AIC et BIC.


***


# Références {-}

Les informations présentées dans ces notes proviennent des fiches d'aide du logiciel R&nbsp;:

R Core Team (2020). *R: A language and environment for statistical computing*. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/

Le manuel suivant de R contient aussi plusieurs informations concernant les calculs statistiques en R&nbsp;:

R Core Team (2020). *An Introduction to R*. R version 4.0.3. URL https://cran.r-project.org/doc/manuals/r-release/R-intro.html

Documentation du package mentionné qui ne vient pas avec l'installation de base de R&nbsp;:

- package `broom`&nbsp;:
    + page web du package sur le CRAN&nbsp;: https://CRAN.R-project.org/package=broom
    + documentation du package&nbsp;: https://broom.tidymodels.org/
    
Une très grande quantité de méthodes statistiques sont implémentées en R. Voici quelques bonnes références sur le sujet.

- Livres&nbsp;:
    + Hothorn, T. et Everitt, B.S. (2014). *A handbook of statistical analyses using R*, third edition. CRC Press.
    + Millot, G. (2018). *Comprendre et réaliser les tests statistiques à l'aide de R: manuel de biostatistique*, 4^e^ édition. De Boeck Supérieur.
- Sites web contenant plusieurs exemples d'analyses statistiques en R&nbsp;:
    + https://stats.idre.ucla.edu/other/dae/ (contient aussi les mêmes exemples avec d'autres logiciels statistiques)
    + https://www.statmethods.net/about/sitemap.html
- Ressources pour dénicher des packages R implémentant des méthodes statistiques particulières&nbsp;:
    + Task views de R&nbsp;: http://cran.r-project.org/web/views/
    + Dépôt informatique de packages R en bio-informatique&nbsp;: http://www.bioconductor.org/


Pour aller plus loin&nbsp;:

- Braun, W. J. et Murdoch, D. (2007). *A first Course in Statistical Programming with R*. Cambridge University Press.



